diff --git a/drivers/tty/serial/8250/8250.h b/drivers/tty/serial/8250/8250.h
index 1aa3e55c8b47..6f6e681b093f 100644
--- a/drivers/tty/serial/8250/8250.h
+++ b/drivers/tty/serial/8250/8250.h
@@ -19,7 +19,10 @@ struct uart_8250_dma {
 	int (*rx_dma)(struct uart_8250_port *p);
 	void (*prepare_tx_dma)(struct uart_8250_port *p);
 	void (*prepare_rx_dma)(struct uart_8250_port *p);
-
+// Perle start for trueport
+	unsigned int (*handle_rx_dma)(struct uart_8250_port *p, u8 iir,
+				      unsigned char status);
+// Perle end for trueport
 	/* Filter function */
 	dma_filter_fn		fn;
 	/* Parameter to the filter function */
@@ -268,14 +271,21 @@ static inline int serial8250_MSR_to_TIOCM(int msr)
 
 	return tiocm;
 }
-
+// Perle start for trueport
+void serial_out_mcr(struct uart_8250_port *up, int value);
 static inline void serial8250_out_MCR(struct uart_8250_port *up, int value)
 {
-	serial_out(up, UART_MCR, value);
-
-	if (up->gpios)
-		mctrl_gpio_set(up->gpios, serial8250_MCR_to_TIOCM(value));
+	serial_out_mcr(up, value);
 }
+void serial_out_mctrl(struct uart_8250_port *up, int mctrl, int mcr_write_mask);
+// static inline void serial8250_out_MCR(struct uart_8250_port *up, int value)
+// {
+// 	serial_out(up, UART_MCR, value);
+
+// 	if (up->gpios)
+// 		mctrl_gpio_set(up->gpios, serial8250_MCR_to_TIOCM(value));
+// }
+// Perle end for trueport
 
 static inline int serial8250_in_MCR(struct uart_8250_port *up)
 {
diff --git a/drivers/tty/serial/8250/8250_core.c b/drivers/tty/serial/8250/8250_core.c
index 3449f8790e46..ebbf2d216fb9 100644
--- a/drivers/tty/serial/8250/8250_core.c
+++ b/drivers/tty/serial/8250/8250_core.c
@@ -559,7 +559,9 @@ static void __init serial8250_isa_init_ports(void)
 		port->membase  = old_serial_port[i].iomem_base;
 		port->iotype   = old_serial_port[i].io_type;
 		port->regshift = old_serial_port[i].iomem_reg_shift;
-
+// Perle start for trueport
+serial8250_set_defaults(up);	/* PERLE */
+// Perle end for trueport
 		port->irqflags |= irqflag;
 		if (serial8250_isa_config != NULL)
 			serial8250_isa_config(i, &up->port, &up->capabilities);
@@ -1066,6 +1068,14 @@ int serial8250_register_8250_port(const struct uart_8250_port *up)
 		uart->rs485_stop_tx	= up->rs485_stop_tx;
 		uart->lsr_save_mask	= up->lsr_save_mask;
 		uart->dma		= up->dma;
+// Perle start for trueport
+		uart->uart_port_index	= up->uart_port_index;
+		uart->set_media_type	= up->set_media_type;
+		uart->mcr_mask			= up->mcr_mask;
+		uart->port.get_mstatus	= up->port.get_mstatus;
+		uart->port.set_termios	= up->port.set_termios;		// duplicate below
+		uart->port.set_mctrl	= up->port.set_mctrl;		// duplicate below
+// Perle end for trueport
 
 		/* Take tx_loadsz from fifosize if it wasn't set separately */
 		if (uart->port.fifosize && !uart->tx_loadsz)
@@ -1129,6 +1139,19 @@ int serial8250_register_8250_port(const struct uart_8250_port *up)
 			uart->dl_read = up->dl_read;
 		if (up->dl_write)
 			uart->dl_write = up->dl_write;
+// Perle start for trueport
+        {
+            uart->char_buf_ptr = &uart->char_buf[0];
+            uart->flag_buf_ptr = &uart->flag_buf[0];
+            timer_setup(&uart->forward_idle_timer            , serial8250_forward_idle_timer            , 0);
+            timer_setup(&uart->forward_force_timer           , serial8250_forward_force_timer           , 0);
+            timer_setup(&uart->forward_send_timer            , serial8250_forward_send_timer            , 0);
+            timer_setup(&uart->sigscan_delay_timer           , serial8250_sigscan_delay_timer           , 0);
+            timer_setup(&uart->rs232_rts_toggle_timer        , serial8250_rs232_rts_toggle_timer        , 0);
+            timer_setup(&uart->rs232_rts_toggle_initial_timer, serial8250_rs232_rts_toggle_initial_timer, 0);
+            timer_setup(&uart->signal_timer                  , serial8250_signal_timer                  , 0);
+        }
+// Perle end for trueport
 
 		if (uart->port.type != PORT_8250_CIR) {
 			if (serial8250_isa_config != NULL)
diff --git a/drivers/tty/serial/8250/8250_port.c b/drivers/tty/serial/8250/8250_port.c
index a17803da83f8..3575dfb750a3 100644
--- a/drivers/tty/serial/8250/8250_port.c
+++ b/drivers/tty/serial/8250/8250_port.c
@@ -37,7 +37,11 @@
 #include <asm/irq.h>
 
 #include "8250.h"
-
+// Perle start for trueport
+#include <linux/perle_serial.h>
+// #include <linux/uart_trace.h>
+#define UART_EXAR_TXCNT     0x0a    /* read-only */
+// Perle end for trueport
 /* Nuvoton NPCM timeout register */
 #define UART_NPCM_TOR          7
 #define UART_NPCM_TOIE         BIT(7)  /* Timeout Interrupt Enable */
@@ -50,6 +54,62 @@
 #else
 #define DEBUG_AUTOCONF(fmt...)	do { } while (0)
 #endif
+// Perle start for trueport
+
+//#define SERIAL_DEBUG_SEND_SIGNAL
+//#define SERIAL_DEBUG_RTSTOGGLE
+#define SERIAL_DEBUG_RTSTOGGLE 1
+#include <linux/sched/signal.h>
+// extern char procSigScan[];	// one for each port
+char procSigScan[256];
+//extern void printkSVT(struct uart_port *p, int line);
+
+int getProcSigScan(int dsline)
+{
+    if(dsline >= 0 && dsline < 256)
+    {
+        return(procSigScan[dsline]);
+    }
+    return(-1);
+}
+EXPORT_SYMBOL(getProcSigScan);
+
+int setProcSigScan(int dsline, int state)
+{
+    if(dsline >= 0 && dsline < 256)
+    {
+        procSigScan[dsline] = (unsigned char)state;
+        return(state);
+    }
+    return(-1);
+}
+EXPORT_SYMBOL(setProcSigScan);
+
+
+#define PROCSS_NONE 0
+#define PROCSS_SCAN 1
+#define PROCSS_START 2
+#define PROCSS_DELAY 3
+
+// events for fsmSigScan
+#define FSMSS_EXIT 0
+#define FSMSS_TIMEOUT 1
+#define FSMSS_SCAN 2
+#define FSMSS_TIOCM 3
+
+/* signal timer definitions */
+#define SIGNAL_TIMER_TM (HZ)
+#define SIGNAL_TIMER_CNT_MAX 50
+
+static int set_modem_info(struct uart_8250_port *up, unsigned int cmd, unsigned int arg);
+static void forward_frame(struct uart_8250_port *up);
+static void push_char(struct uart_8250_port *up, unsigned int lsrStatus, unsigned int overrun, unsigned char ch, unsigned char st);
+static void push_char_frame(struct uart_8250_port *up, unsigned char ch, unsigned char st);
+static void push_char_end(struct uart_8250_port *up, unsigned char ch, unsigned char st);
+static void store_char(struct uart_8250_port *up, unsigned char ch, unsigned char st);
+static void fix_port_mctrl_from_mcr(struct uart_8250_port *up);
+//static void serial8250_rpm_get_tx(struct uart_8250_port *p);
+// Perle end for trueport
 
 /*
  * Here we define the default xmit fifo size used for each type of UART.
@@ -332,6 +392,1328 @@ static const struct serial8250_config uart_config[] = {
 	},
 };
 
+// Perle start for trueport
+
+
+static int set_modem_info(struct uart_8250_port *up, unsigned int cmd, unsigned int arg)
+{
+    unsigned char or, xor, mask=0, outs;
+
+
+    or = xor = 0;
+    if ((arg & TIOCM_RTS) && !(up->rs232_rts_toggle))
+        or |= UART_MCR_RTS;
+    if (arg & TIOCM_DTR)
+        or |= UART_MCR_DTR;
+    if (arg & TIOCM_OUT1)
+        or |= UART_MCR_OUT1;
+    if (arg & TIOCM_OUT2)
+        or |= UART_MCR_OUT2;
+    if (arg & TIOCM_LOOP)
+        or |= UART_MCR_LOOP;
+
+    switch (cmd)
+    {
+        case TIOCMBIS:
+            break;
+        case TIOCMBIC:
+            xor = or;
+            break;
+        case TIOCMSET:
+            mask = (UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT1|UART_MCR_OUT2|UART_MCR_LOOP);
+            xor = ~or & mask;
+            or = mask;
+            break;
+        case TIOCMAPDTR:
+            mask = UART_MCR_DTR;
+            break;
+        case TIOCMAPRTS:
+            mask = UART_MCR_RTS;
+            break;
+    }
+
+    switch (cmd)
+    {
+
+        case TIOCMAPDTR:
+        case TIOCMAPRTS:
+            outs = up->out1|up->out2;
+            // if unmapping signal restore value
+            if((outs & mask) && !(or & (UART_MCR_OUT1|UART_MCR_OUT2)))
+                up->mcr = (up->mcr & ~mask) | (up->MCRmap & mask);
+            if(or & UART_MCR_OUT1)
+                up->out1 |= mask;
+            else
+                up->out1 &= ~mask;
+            if(or & UART_MCR_OUT2)
+                up->out2 |= mask;
+            else
+                up->out2 &= ~mask;
+            or = xor = 0;
+            break;
+        case TIOCMSET:
+        case TIOCMBIS:
+        case TIOCMBIC:
+            up->MCRmap = (up->MCRmap | or) ^ xor;   // save new MCR pattern
+            break;
+
+    }
+
+    if(up->out1)                                // re-map OUT1
+    {
+        or |= up->out1;
+        xor = (xor | up->out1) ^ (up->MCRmap & UART_MCR_OUT1 ? up->out1 : 0);
+    }
+    if(up->out2)                                // re-map OUT2
+    {
+        or |= up->out2;
+        xor = (xor | up->out2) ^ (up->MCRmap & UART_MCR_OUT2 ? up->out2 : 0);
+    }
+
+    {
+        u8  new_mcr;
+
+        or &= ~(UART_MCR_OUT1|UART_MCR_OUT2);
+        xor &= ~(UART_MCR_OUT1|UART_MCR_OUT2);
+        new_mcr = (up->last_mcr_written | or) ^ xor;
+
+        // new_mcr = (new_mcr & up->mcr_mask) | up->mcr_force | up->mcr;   // copied from serial8250_do_set_mctrl
+        	new_mcr = serial8250_TIOCM_to_MCR(up->port.mctrl);
+
+	new_mcr |= up->mcr;
+        serial_out_mcr(up, new_mcr);
+    }
+    return 0;
+}
+
+
+// void x86HardwareTransceiverEnable(struct uart_port *port, int mode)
+// {
+// 	struct uart_8250_port *up = up_to_u8250p(port);
+// 	struct exar8250 *priv = up->exar8250priv;
+// 	int chip_idx = up->uart_port_index & 0x7;	// 0 -> 7
+	
+// //	printk(KERN_INFO "%s(%d, %d)\n", __FUNCTION__, up->uart_port_index, mode); 
+
+// 	switch(port->card_id)
+// 	{
+// 	case VCARD_ID_CISCO_DXE_16:
+// 	case VCARD_ID_CISCO_DXE_8:
+// 	case VCARD_ID_CISCO_DCE_16:
+// 	case VCARD_ID_CISCO_DCE_8:
+// 		{
+// 			unsigned char value, mask_bits, enable_bit;
+// 			int chip_reg = (chip_idx & 0x4) == 0 ? UART_EXAR_MPIOLVL_7_0 : UART_EXAR_MPIOLVL_15_8;
+
+// 			mode &= SERIAL_8250_MEDIA_TYPE_MASK;
+// 			mask_bits = 3 << ((chip_idx & 3) << 1);
+// 			enable_bit = ((mode == SERIAL_8250_MEDIA_TYPE_232_DCE) ? 1 : 0) | ((mode == SERIAL_8250_MEDIA_TYPE_232) ? 2 : 0);
+// 			enable_bit = enable_bit << ((chip_idx & 3) << 1);
+			
+// 			value = serial_port_in(port, chip_reg);
+// 			value &= ~mask_bits;
+// 			value |= enable_bit;
+// 	//printk(KERN_INFO "value=0x%x mask=0x%x enable=0x%x\n", value, mask_bits, enable_bit); 
+// 			serial_port_out(port, chip_reg, value);
+// 		}
+// 		break;
+// 	case VCARD_ID_CISCO_MULTI_16:
+// 		{
+// 			u8 __iomem *pM, *pL;
+// 			int i, chip = 0;
+// 			u8 reg, bit;
+// 			unsigned long flags;
+			
+// 			pM = pL = priv->virt;
+// 			if(up->uart_port_index > 7)
+// 			{
+// 				pL += 0x2000;
+// 				chip = 1;
+// 			}
+			
+// 			switch(mode & SERIAL_8250_MEDIA_TYPE_MASK)
+// 			{
+// 			case SERIAL_8250_MEDIA_TYPE_232:
+// 			case SERIAL_8250_MEDIA_TYPE_232_DCE:
+// 				up->mcr_signal_flips = 0;
+// 				reg = VSERIES_MULTI_CARD_232_ENABLE |
+// 					VSERIES_MULTI_CARD_ENABLED;
+// 				break;
+// 			case SERIAL_8250_MEDIA_TYPE_422:
+// 				up->mcr_signal_flips = UART_MCR_RTS;
+// 				reg = VSERIES_MULTI_CARD_NOT_232 |
+// 					VSERIES_MULTI_CARD_ENABLED;
+// 				if(mode & SERIAL_8250_MEDIA_TERMINATION)
+// 					reg |= VSERIES_MULTI_CARD_RX_TERM;
+// 				break;
+// 			case SERIAL_8250_MEDIA_TYPE_485_FULL:
+// 				up->mcr_signal_flips = UART_MCR_RTS;
+// 				reg = VSERIES_MULTI_CARD_NOT_232 |
+// 					VSERIES_MULTI_CARD_ENABLED;
+// 				if(mode & SERIAL_8250_MEDIA_TERMINATION)
+// 					reg |= VSERIES_MULTI_CARD_RX_TERM | VSERIES_MULTI_CARD_TX_TERM;
+// 				break;
+// 			case SERIAL_8250_MEDIA_TYPE_485_HALF:
+// 				up->mcr_signal_flips = UART_MCR_RTS;
+// 				reg = VSERIES_MULTI_CARD_NOT_232 |
+// 					VSERIES_MULTI_CARD_ENABLED |
+// 					VSERIES_MULTI_CARD_HALF_DUPLEX;
+// 				if(mode & SERIAL_8250_MEDIA_TERMINATION)
+// 					reg |= VSERIES_MULTI_CARD_TX_TERM;
+// 				break;
+// 			default:
+// 				up->mcr_signal_flips = 0;
+// 				reg = VSERIES_MULTI_CARD_NOT_232;
+// 				break;
+// 			}
+// 			if(mode & SERIAL_8250_MEDIA_FAST)
+// 				reg |= VSERIES_MULTI_CARD_FAST;
+					
+// 			bit = 1 << chip_idx;	// this is the bit we are changing
+			
+// 	//printk(KERN_INFO "uart_port_index=%d chip=%d, reg=0x%x bit=0x%x\n", up->uart_port_index, chip, reg, bit); 
+
+// 			spin_lock_irqsave(&priv->lock, flags);
+// 			for(i = 0; i < VSERIES_MULTI_CARD_BIT_SIZE; i++)
+// 			{
+// 				u8 latch;
+// 				u8 want = ((reg >> i) & 1) << chip_idx;
+// 				if(((latch = priv->latches[chip][i]) & bit) != want)
+// 				{
+// 					latch ^= bit;								// flip bit
+// 					priv->latches[chip][i] = latch;				// update mirror
+// 	//printk(KERN_INFO "latch[%d][%d]=0x%x\n", chip, i, latch); 
+// 					writeb(latch, pM + UART_EXAR_MPIOLVL_7_0);	// present data
+// 					writeb(0x00, pL + UART_EXAR_MPIOLVL_15_8);	// all low
+// 					writeb(1 << i, pL + UART_EXAR_MPIOLVL_15_8);// clock single bit high
+// 				}
+// 			}
+// 			spin_unlock_irqrestore(&priv->lock, flags);
+// 		}
+// 		break;
+// 	}
+// }
+// EXPORT_SYMBOL(x86HardwareTransceiverEnable);
+
+// fixup mctrl in port structure for serial_core.c, otherwise TIOCMGET will
+// not return the correct state of RTS for 485/422 mode because
+// the omap_serial.c driver can change RTS for these modes
+// this is also necessary in 232 mode, because other ioctls can change RTS and DTR
+static void fix_port_mctrl_from_mcr(struct uart_8250_port *up)
+{
+    unsigned int setbits=0;
+    unsigned int clearbits=0;
+
+    if (up->last_mcr_written & UART_MCR_RTS)
+    {
+        setbits|=TIOCM_RTS;
+    }
+    else
+    {
+        clearbits|=TIOCM_RTS;
+    }
+
+    if (up->last_mcr_written & UART_MCR_DTR)
+    {
+        setbits|=TIOCM_DTR;
+    }
+    else
+    {
+        clearbits|=TIOCM_DTR;
+    }
+    up->port.mctrl = (up->port.mctrl & (~clearbits)) | setbits;
+}
+
+void serial_out_mcr(struct uart_8250_port *up, int value)
+{
+    serial_out(up, UART_MCR, value);
+    up->last_mcr_written=value;
+    fix_port_mctrl_from_mcr(up);
+
+    // if(up->traceMask & TRACE_BITS_SIGNALS)
+    // {
+    //     uartTraceAddSignals(up->tracePortIndex, &up->traceSignals, value, up->last_msr_read);
+    // }
+}
+EXPORT_SYMBOL(serial_out_mcr);
+
+void serial_out_mctrl(struct uart_8250_port *up, int mctrl, int mcr_write_mask)
+{
+	int value = 0;
+	
+    if(mctrl & TIOCM_RTS)
+        value |= UART_MCR_RTS;
+    if(mctrl & TIOCM_DTR)
+        value |= UART_MCR_DTR;
+    if(mctrl & TIOCM_OUT1)
+        value |= UART_MCR_OUT1;
+    if(mctrl & TIOCM_OUT2)
+        value |= UART_MCR_OUT2;
+    if(mctrl & TIOCM_LOOP)
+        value |= UART_MCR_LOOP;
+	
+	if(mcr_write_mask != 0)
+	{
+		int mcr = serial_in(up, UART_MCR);	
+		mcr = (mcr & ~mcr_write_mask) | (value & mcr_write_mask);
+		serial_out(up, UART_MCR, mcr);
+	}
+
+    up->last_mcr_written=value;
+    fix_port_mctrl_from_mcr(up);
+
+    // if(up->traceMask & TRACE_BITS_SIGNALS)
+    // {
+    //     uartTraceAddSignals(up->tracePortIndex, &up->traceSignals, value, up->last_msr_read);
+    // }
+}
+EXPORT_SYMBOL(serial_out_mctrl);
+
+int serial_in_msr(struct uart_8250_port *up)
+{
+	int value;
+	
+// #if !defined(CONFIG_PERLE_IOLAN)
+// 	value = serial_in(up, UART_MSR);
+// #else
+	int delta;
+
+	if(!up->port.get_mstatus)
+		value = serial_in(up, UART_MSR);
+	else
+	{
+		unsigned int tiocm = up->port.get_mstatus(&up->port);
+		
+		value = (!!(tiocm & TIOCM_CTS) ? UART_MSR_CTS : 0) |
+					 (!!(tiocm & TIOCM_DSR) ? UART_MSR_DSR : 0) |
+					 (!!(tiocm & TIOCM_CD)  ? UART_MSR_DCD : 0) |
+					 (!!(tiocm & TIOCM_RI)  ? UART_MSR_RI : 0);
+	}
+	
+	delta = (value ^ up->last_msr_read) >> 4;
+	if(value & UART_MSR_RI)
+		delta &= ~UART_MSR_TERI;
+	
+	value |= delta;
+
+//printk(KERN_INFO "(%s,%d): msr=0x%x\n",__FUNCTION__,__LINE__,value);
+	up->last_msr_read = value;
+    // if(up->traceMask & TRACE_BITS_SIGNALS)
+    // {
+    //     uartTraceAddSignals(up->tracePortIndex, &up->traceSignals, up->last_mcr_written, value);
+    // }
+
+	return(value);
+}
+static void flush_rx(struct uart_8250_port *up)
+{
+    serial_out(up, UART_FCR, up->fcr|UART_FCR_CLEAR_RCVR);
+}
+/*
+ * ===============================================
+ * rtscontrol routines
+ * ===============================================
+ */
+static unsigned int serial_in_UART_TXCNT(struct uart_8250_port *up)
+{
+    int i;
+    int count1 = -1;
+    int count2 = -1;
+
+    count1 = serial_in(up, UART_EXAR_TXCNT);
+    for(i = 0; i < 16; i++)
+    {
+        count2 = serial_in(up, UART_EXAR_TXCNT);
+        if (count1 == count2)
+        {
+            break;
+        }
+        count1 = count2;
+    }
+    return(count1);
+}
+//
+// rs232 rts toggle timeout
+//
+void serial8250_rs232_rts_toggle_timer(struct timer_list *t)
+{
+    int status;
+    int rts_toggle_delay;
+    unsigned long flags;
+    struct uart_8250_port *up = from_timer(up, t, rs232_rts_toggle_timer);
+	struct uart_port *port = &up->port;	// SVT
+    int tmp_mcr;
+
+#ifdef SERIAL_DEBUG_RTSTOGGLE
+    // printk("(%s,%d): data = 0x%x\n", __FUNCTION__,__LINE__,(unsigned int)data);
+#endif
+
+    tmp_mcr = serial_in(up, UART_MCR);
+    if (!(tmp_mcr & UART_MCR_RTS))
+    {
+#ifdef SERIAL_DEBUG_RTSTOGGLE
+        printk("ps_rs232_rts_toggle_timer: RTS already down\n");
+#endif
+        return;
+    }
+    status = serial_in(up, UART_LSR);
+    up->lsr_saved_flags |= status & LSR_SAVE_FLAGS;
+
+    if (status & UART_LSR_TEMT)
+    {
+//SVT     local_irq_save(flags);
+		spin_lock_irqsave(&port->lock, flags);
+        tmp_mcr &= ~UART_MCR_RTS;
+        serial_out_mcr(up, tmp_mcr);
+//SVT     local_irq_restore(flags);
+		spin_unlock_irqrestore(&port->lock, flags);
+#ifdef SERIAL_DEBUG_RTSTOGGLE
+        printk("ps_rs232_rts_toggle_timer: TEMT empty, set RTS down\n");
+#endif
+    }
+    else
+    {
+        rts_toggle_delay = serial_in_UART_TXCNT(up);
+        if (rts_toggle_delay == 0)
+        {
+            rts_toggle_delay = 1;
+        }
+        rts_toggle_delay *= up->rs232_rts_toggle_char_timeout * HZ / 1000;
+        mod_timer(&up->rs232_rts_toggle_timer, jiffies + rts_toggle_delay);
+#ifdef SERIAL_DEBUG_RTSTOGGLE
+        printk("ps_rs232_rts_toggle_timer: set rs232_rts_toggle_timer, %d\n",rts_toggle_delay);
+#endif
+    }
+}
+
+EXPORT_SYMBOL(serial8250_rs232_rts_toggle_timer);
+//
+// rs232 rts toggle initial timeout
+//
+void serial8250_rs232_rts_toggle_initial_timer(struct timer_list *t)
+{
+    struct uart_8250_port *up = from_timer(up, t, rs232_rts_toggle_initial_timer);
+	unsigned long flags;
+
+// #ifdef SERIAL_DEBUG_RTSTOGGLE
+//     printk("ps_rs232_rts_toggle_initial_timer: data = 0x%x, call transmit_chars\n", (unsigned int)data);
+// #endif
+
+    serial8250_rpm_get_tx(up);
+
+    spin_lock_irqsave(&up->port.lock, flags);
+
+    up->ier |= UART_IER_THRI;
+    serial_out(up, UART_IER, up->ier);
+
+    serial8250_tx_chars(up);
+
+    spin_unlock_irqrestore(&up->port.lock, flags);
+}
+
+EXPORT_SYMBOL(serial8250_rs232_rts_toggle_initial_timer);
+
+/*
+ * ===============================================
+ * serialt (uart trace) routines
+ * ===============================================
+ */
+
+// static void trace_special(struct uart_8250_port *up, short sp)
+// {
+//     if(up->traceMask & TRACE_BITS_SPECIAL)
+//     {
+//         uartTraceAddSpecial(up->tracePortIndex, sp);
+//     }
+// }
+/*
+ * ===============================================
+ * packet forwarding routines
+ * ===============================================
+ */
+
+#define SERIAL_DEBUG_FORWARDING 0
+/*
+    this routine is a copy of uart_insert_char from serial_core.c
+    we need this here because if we're buffering data because of packet forwarding
+    we need to decide if we're ignoring data because of line errors now before we
+    store it in our packet forward buffer. we don't want to use space in our packet
+    forward buffer that will be tossed later in serial_core.c.  Also when we call
+    uart_insert_char to push the data up to serial_core we won't have the LSR value
+    since we're not storing it in our packet forward buffer.
+
+    returns:    1   OK to store the data
+                0   discard the data
+*/
+static int uart_insert_char_ok(struct uart_port *port, unsigned int status,
+         unsigned int overrun, unsigned int ch, unsigned int flag)
+{
+    int returnCode=0;
+
+    // check for any LSR flags other than overrun
+    if ((status & port->ignore_status_mask & ~overrun) == 0)
+    {
+        returnCode=1;
+    }
+
+    /*
+     * Overrun is special.  Since it's reported immediately,
+     * it doesn't affect the current character.
+     */
+    if (status & ~port->ignore_status_mask & overrun)
+    {
+        returnCode=1;
+    }
+    return(returnCode);
+}
+
+//
+// put character in the correct buffer based on forwarding config
+//
+static void push_char(struct uart_8250_port *up, unsigned int lsrStatus, unsigned int overrun, unsigned char ch, unsigned char st)
+{
+    struct uart_port *port = &up->port;
+    int restarttimerflag = 0;
+    unsigned short      forwarding = up->forwarding;       // options for packet forwarding
+
+#ifdef SERIAL_DEBUG_FORWARDING
+    printk("push_char %d: start, up 0x%x, forwarding 0x%x, ch %x, st %x\n", __LINE__, (unsigned int)up, up->forwarding, ch, st);
+#endif
+
+    if (!uart_insert_char_ok(port,lsrStatus,overrun,ch,st))
+    {
+        return;
+    }
+
+    if(up->oneshot_forwarding & DS_ONESHOT_ON_DIRECT_TRIGGER)
+    {
+        if(ch != up->direct_trigger)                        // eat rxed character until match
+            return;
+        up->oneshot_forwarding &= ~DS_ONESHOT_ON_DIRECT_TRIGGER;    // clear DIRECT_TRIGGER bit
+    }
+
+    if (forwarding == 0)
+    {
+        // forwarding not configured
+        uart_insert_char(port,lsrStatus,overrun,ch,st);
+    }
+    else
+    {
+        // forwarding configured
+        up->stored_char = FALSE;
+
+        if (forwarding & PERLE_SERIAL_FORWARD_ON_FRAME)
+        {
+#ifdef SERIAL_DEBUG_FORWARDING
+            printk("push_char: FORWARD_ON_FRAME\n");
+#endif
+            push_char_frame(up, ch, st);
+        }
+        else
+        {
+            if (up->count == 0)
+            {
+                 restarttimerflag = TRUE;
+            }
+            else
+            {
+                 restarttimerflag = FALSE;
+            }
+            if (forwarding & PERLE_SERIAL_FORWARD_ON_CHAR)
+            {
+#ifdef SERIAL_DEBUG_FORWARDING
+                printk("push_char: FORWARD_ON_CHAR\n");
+#endif
+                push_char_end(up, ch, st);
+            }
+
+            if (forwarding & DS_FORWARD_ON_TIME)
+            {
+#ifdef SERIAL_DEBUG_FORWARDING
+                printk("push_char: DS_FORWARD_ON_TIME\n");
+#endif
+                if (restarttimerflag)
+                {
+#ifdef SERIAL_DEBUG_FORWARDING
+                    printk("push_char: restart forward on timer\n");
+#endif
+                    mod_timer(&up->forward_force_timer, jiffies + up->force_time * HZ / 1000);
+                }
+                // forward when a total time is reached
+                store_char(up, ch, st);
+            }
+
+            if (forwarding & DS_FORWARD_ON_IDLE)
+            {
+#ifdef SERIAL_DEBUG_FORWARDING
+                printk("push_char: DS_FORWARD_ON_IDLE\n");
+#endif
+                if (jiffies != up->last_idle_time || restarttimerflag)
+                {
+#ifdef SERIAL_DEBUG_FORWARDING
+                    printk("push_char: restart idle timer\n");
+#endif
+                    up->last_idle_time = jiffies;
+                    mod_timer(&up->forward_idle_timer, jiffies + up->idle_time * HZ / 1000);
+                }
+                // forward when the idle timer expires
+                store_char(up, ch, st);
+            }
+
+            if (forwarding & DS_FORWARD_ON_COUNT)
+            {
+                // forward when a count is reached
+#ifdef SERIAL_DEBUG_FORWARDING
+                printk("push_char: DS_FORWARD_ON_COUNT\n");
+#endif
+                store_char(up, ch, st);
+                if (up->count == up->packet_size)
+                {
+                    forward_frame(up);
+                }
+            }
+       }
+    }
+#ifdef SERIAL_DEBUG_FORWARDING
+    printk("push_char: end, up 0x%x\n", (unsigned int)up);
+#endif
+}
+
+//
+// put character in the correct buffer based if forwarding frame
+//
+static void push_char_frame(struct uart_8250_port *up, unsigned char ch, unsigned char st)
+{
+#ifdef SERIAL_DEBUG_FORWARDING
+    printk("push_char_frame: start, up 0x%x, state %d\n",(unsigned int)up, up->forward_state);
+#endif
+
+    switch (up->forward_state)
+    {
+    case PERLE_SERIAL_FORWARD_STATE_START_1OF1:
+        if (ch == up->start_frame1)
+        {
+            switch (up->start_transmit_rule)
+            {
+            case DS_FORWARD_TRANS_STRIP:
+                break;
+            case DS_FORWARD_TRANS_TRIG:
+                store_char(up, ch, st);
+                break;
+            default:
+                break;
+            }
+            if (up->forwarding & DS_FORWARD_END_CHAR2)
+            {
+                up->forward_state = PERLE_SERIAL_FORWARD_STATE_END_1OF2;
+            }
+            else
+            {
+                up->forward_state = PERLE_SERIAL_FORWARD_STATE_END_1OF1;
+            }
+        }
+        break;
+
+    case PERLE_SERIAL_FORWARD_STATE_START_1OF2:
+        if (ch == up->start_frame1)
+        {
+            switch (up->start_transmit_rule)
+            {
+            case DS_FORWARD_TRANS_STRIP:
+                break;
+            case DS_FORWARD_TRANS_TRIG:
+                up->saved_ch = ch;
+                up->saved_st = st;
+                break;
+            default:
+                break;
+            }
+            up->forward_state = PERLE_SERIAL_FORWARD_STATE_START_2OF2;
+        }
+        break;
+
+    case PERLE_SERIAL_FORWARD_STATE_START_2OF2:
+        if (ch == up->start_frame2)
+        {
+            switch (up->start_transmit_rule)
+            {
+            case DS_FORWARD_TRANS_STRIP:
+                break;
+            case DS_FORWARD_TRANS_TRIG:
+                store_char(up,up->saved_ch, up->saved_st);
+                up->stored_char = FALSE;
+                store_char(up, ch, st);
+                break;
+            default:
+                break;
+            }
+            if (up->forwarding & DS_FORWARD_END_CHAR2)
+            {
+                up->forward_state = PERLE_SERIAL_FORWARD_STATE_END_1OF2;
+            }
+            else
+            {
+                up->forward_state = PERLE_SERIAL_FORWARD_STATE_END_1OF1;
+            }
+        }
+        else
+        {
+        if (ch == up->start_frame1)
+        {
+        switch (up->start_transmit_rule)
+        {
+        case DS_FORWARD_TRANS_STRIP:
+            break;
+        case DS_FORWARD_TRANS_TRIG:
+            up->saved_ch = ch;
+            up->saved_st = st;
+            break;
+        default:
+            break;
+        }
+        }
+        else
+        {
+        up->forward_state = PERLE_SERIAL_FORWARD_STATE_START_1OF2;
+        }
+        }
+        break;
+
+    case PERLE_SERIAL_FORWARD_STATE_END_1OF1:
+        if (ch == up->end_frame1)
+        {
+            switch (up->end_transmit_rule)
+            {
+            case DS_FORWARD_TRANS_STRIP:
+                forward_frame(up);
+        up->forward_state = up->base_state;
+                break;
+            case DS_FORWARD_TRANS_TRIG:
+                store_char(up, ch, st);
+                forward_frame(up);
+        up->forward_state = up->base_state;
+                break;
+            case DS_FORWARD_TRANS_TRIG_1:
+                store_char(up, ch, st);
+                up->forward_state = PERLE_SERIAL_FORWARD_STATE_WAITING_1OF1;
+                break;
+            case DS_FORWARD_TRANS_TRIG_2:
+                store_char(up, ch, st);
+                up->forward_state = PERLE_SERIAL_FORWARD_STATE_WAITING_1OF2;
+                break;
+            default:
+                break;
+            }
+        }
+        else
+        {
+            store_char(up, ch, st);
+        }
+        break;
+
+    case PERLE_SERIAL_FORWARD_STATE_END_1OF2:
+        if (ch == up->end_frame1)
+        {
+            switch (up->end_transmit_rule)
+            {
+            case DS_FORWARD_TRANS_STRIP:
+                up->saved_ch = ch;
+                up->saved_st = st;
+                break;
+            case DS_FORWARD_TRANS_TRIG:
+            case DS_FORWARD_TRANS_TRIG_1:
+            case DS_FORWARD_TRANS_TRIG_2:
+                store_char(up, ch, st);
+                break;
+            default:
+                break;
+            }
+            up->forward_state = PERLE_SERIAL_FORWARD_STATE_END_2OF2;
+        }
+        else
+        {
+            store_char(up, ch, st);
+        }
+        break;
+
+    case PERLE_SERIAL_FORWARD_STATE_END_2OF2:
+        if (ch == up->end_frame2)
+        {
+            switch (up->end_transmit_rule)
+            {
+            case DS_FORWARD_TRANS_STRIP:
+                forward_frame(up);
+                up->forward_state = up->base_state;
+                break;
+            case DS_FORWARD_TRANS_TRIG:
+                store_char(up, ch, st);
+                forward_frame(up);
+                up->forward_state = up->base_state;
+                break;
+            case DS_FORWARD_TRANS_TRIG_1:
+                store_char(up, ch, st);
+                up->forward_state = PERLE_SERIAL_FORWARD_STATE_WAITING_1OF1;
+                break;
+            case DS_FORWARD_TRANS_TRIG_2:
+                store_char(up, ch, st);
+                up->forward_state = PERLE_SERIAL_FORWARD_STATE_WAITING_1OF2;
+                break;
+            default:
+                break;
+            }
+        }
+        else
+        {
+            switch (up->end_transmit_rule)
+            {
+            case DS_FORWARD_TRANS_STRIP:
+                store_char(up,up->saved_ch, up->saved_st);
+                up->stored_char = FALSE;
+                break;
+            case DS_FORWARD_TRANS_TRIG:
+            case DS_FORWARD_TRANS_TRIG_1:
+            case DS_FORWARD_TRANS_TRIG_2:
+                break;
+            default:
+                break;
+            }
+        if (ch == up->end_frame1)
+        {
+        switch (up->end_transmit_rule)
+        {
+        case DS_FORWARD_TRANS_STRIP:
+            up->saved_ch = ch;
+            up->saved_st = st;
+            break;
+        case DS_FORWARD_TRANS_TRIG:
+        case DS_FORWARD_TRANS_TRIG_1:
+        case DS_FORWARD_TRANS_TRIG_2:
+            store_char(up, ch, st);
+            break;
+        default:
+            break;
+        }
+        }
+        else
+        {
+        store_char(up, ch, st);
+        up->forward_state = PERLE_SERIAL_FORWARD_STATE_END_1OF2;
+        }
+        }
+        break;
+
+    case PERLE_SERIAL_FORWARD_STATE_WAITING_1OF1:
+        store_char(up, ch, st);
+        forward_frame(up);
+        up->forward_state = up->base_state;
+        break;
+
+    case PERLE_SERIAL_FORWARD_STATE_WAITING_1OF2:
+        store_char(up, ch, st);
+        up->forward_state = PERLE_SERIAL_FORWARD_STATE_WAITING_2OF2;
+        break;
+
+    case PERLE_SERIAL_FORWARD_STATE_WAITING_2OF2:
+        store_char(up, ch, st);
+        forward_frame(up);
+        up->forward_state = up->base_state;
+        break;
+
+    default:
+        break;
+    }
+#ifdef SERIAL_DEBUG_FORWARDING
+    printk("push_char_frame: end state %d\n",up->forward_state);
+#endif
+}
+
+//
+// put character in the correct buffer based if forwarding end char
+//
+static void push_char_end(struct uart_8250_port *up, unsigned char ch, unsigned char st)
+{
+#ifdef SERIAL_DEBUG_FORWARDING
+    printk("push_char_end: start, up 0x%x, state %d\n",(unsigned int)up, up->forward_state);
+#endif
+
+    switch (up->forward_state)
+    {
+    case PERLE_SERIAL_FORWARD_STATE_END_1OF1:
+        if (ch == up->trigger_char1)
+        {
+            switch (up->end_transmit_rule)
+            {
+            case DS_FORWARD_TRANS_STRIP:
+                up->stored_char = TRUE;
+                forward_frame(up);
+        up->forward_state = up->base_state;
+                break;
+            case DS_FORWARD_TRANS_TRIG:
+                store_char(up, ch, st);
+                forward_frame(up);
+        up->forward_state = up->base_state;
+                break;
+            case DS_FORWARD_TRANS_TRIG_1:
+                store_char(up, ch, st);
+                up->forward_state = PERLE_SERIAL_FORWARD_STATE_WAITING_1OF1;
+                break;
+            case DS_FORWARD_TRANS_TRIG_2:
+                store_char(up, ch, st);
+                up->forward_state = PERLE_SERIAL_FORWARD_STATE_WAITING_1OF2;
+                break;
+            default:
+                break;
+            }
+        }
+        else
+        {
+            store_char(up, ch, st);
+        }
+        break;
+
+    case PERLE_SERIAL_FORWARD_STATE_END_1OF2:
+        if (ch == up->trigger_char1)
+        {
+            switch (up->end_transmit_rule)
+            {
+            case DS_FORWARD_TRANS_STRIP:
+                up->saved_ch = ch;
+                up->saved_st = st;
+                up->stored_char = TRUE;
+                break;
+            case DS_FORWARD_TRANS_TRIG:
+            case DS_FORWARD_TRANS_TRIG_1:
+            case DS_FORWARD_TRANS_TRIG_2:
+                store_char(up, ch, st);
+                break;
+            default:
+                break;
+            }
+            up->forward_state = PERLE_SERIAL_FORWARD_STATE_END_2OF2;
+        }
+        else
+        {
+            store_char(up, ch, st);
+        }
+        break;
+
+    case PERLE_SERIAL_FORWARD_STATE_END_2OF2:
+        if (ch == up->trigger_char2)
+        {
+            switch (up->end_transmit_rule)
+            {
+            case DS_FORWARD_TRANS_STRIP:
+                up->stored_char = TRUE;
+                forward_frame(up);
+                up->forward_state = up->base_state;
+                break;
+            case DS_FORWARD_TRANS_TRIG:
+                store_char(up, ch, st);
+                forward_frame(up);
+                up->forward_state = up->base_state;
+                break;
+            case DS_FORWARD_TRANS_TRIG_1:
+                store_char(up, ch, st);
+                up->forward_state = PERLE_SERIAL_FORWARD_STATE_WAITING_1OF1;
+                break;
+            case DS_FORWARD_TRANS_TRIG_2:
+                store_char(up, ch, st);
+                up->forward_state = PERLE_SERIAL_FORWARD_STATE_WAITING_1OF2;
+                break;
+            default:
+                break;
+            }
+        }
+        else
+        {
+            switch (up->end_transmit_rule)
+            {
+            case DS_FORWARD_TRANS_STRIP:
+                store_char(up,up->saved_ch, up->saved_st);
+                up->stored_char = FALSE;
+                break;
+            case DS_FORWARD_TRANS_TRIG:
+            case DS_FORWARD_TRANS_TRIG_1:
+            case DS_FORWARD_TRANS_TRIG_2:
+                break;
+            default:
+                break;
+            }
+            if (ch == up->trigger_char1)
+            {
+                switch (up->end_transmit_rule)
+                {
+                case DS_FORWARD_TRANS_STRIP:
+                    up->saved_ch = ch;
+                    up->saved_st = st;
+                    up->stored_char = TRUE;
+                    break;
+                case DS_FORWARD_TRANS_TRIG:
+                case DS_FORWARD_TRANS_TRIG_1:
+                case DS_FORWARD_TRANS_TRIG_2:
+                    store_char(up, ch, st);
+                    break;
+                default:
+                    break;
+                }
+            }
+            else
+            {
+                store_char(up, ch, st);
+                up->forward_state = PERLE_SERIAL_FORWARD_STATE_END_1OF2;
+            }
+        }
+        break;
+
+    case PERLE_SERIAL_FORWARD_STATE_WAITING_1OF1:
+        store_char(up, ch, st);
+        forward_frame(up);
+        up->forward_state = up->base_state;
+        break;
+
+    case PERLE_SERIAL_FORWARD_STATE_WAITING_1OF2:
+        store_char(up, ch, st);
+        up->forward_state = PERLE_SERIAL_FORWARD_STATE_WAITING_2OF2;
+        break;
+
+    case PERLE_SERIAL_FORWARD_STATE_WAITING_2OF2:
+        store_char(up, ch, st);
+        forward_frame(up);
+        up->forward_state = up->base_state;
+        break;
+
+    default:
+        break;
+    }
+#ifdef SERIAL_DEBUG_FORWARDING
+    printk("push_char_end: end state %d\n",up->forward_state);
+#endif
+}
+
+//
+// save the char and status in our flip buffer
+//
+static void store_char(struct uart_8250_port *up, unsigned char ch, unsigned char st)
+{
+#ifdef SERIAL_DEBUG_FORWARDING
+    printk("store_char: start up 0x%x, state %d, count %d\n",(unsigned int)up, up->stored_char,up->count);
+#endif
+    if (!up->stored_char)
+    {
+
+        *up->char_buf_ptr = ch;
+        up->char_buf_ptr++;
+        *up->flag_buf_ptr = st;
+        up->flag_buf_ptr++;
+        up->count++;
+        up->stored_char = TRUE;
+        if (up->count == PERLE_SERIAL_DS_FLIPBUF_SIZE)
+        {
+            forward_frame(up);
+        }
+    }
+#ifdef SERIAL_DEBUG_FORWARDING
+    printk("store_char: end state %d, count %d\n",up->stored_char,up->count);
+#endif
+}
+
+//
+// forward the frame based on forwarding config
+//
+static void forward_frame(struct uart_8250_port *up)
+{
+    struct uart_port *port = &up->port;
+    typeof(port->icount.buf_overrun) overrun=port->icount.buf_overrun;
+
+#ifdef SERIAL_DEBUG_FORWARDING
+        printk("forward_frame: start, get count %d, count %d, number %d\n",up->get_count, up->count, up->buf_num);
+#endif
+    if (up->get_count == 0)
+    {
+        if (up->forwarding & DS_FORWARD_ON_IDLE)
+        {
+            del_timer(&up->forward_idle_timer);
+        }
+        if (up->forwarding & DS_FORWARD_ON_TIME)
+        {
+            del_timer(&up->forward_force_timer);
+        }				
+	}
+	// We do this again since the other CPU could have called forward_frame() when calling del_timer_sync()
+    if (up->get_count == 0)
+    {
+//        unsigned long flags;
+
+//SVT     local_irq_save(flags);
+		//spin_lock_irqsave(&port->lock, flags);
+
+        if (up->buf_num)
+        {
+            up->get_char_ptr = &up->char_buf[PERLE_SERIAL_DS_FLIPBUF_SIZE];
+            up->get_flag_ptr = &up->flag_buf[PERLE_SERIAL_DS_FLIPBUF_SIZE];
+            up->buf_num = 0;
+            up->char_buf_ptr = &up->char_buf[0];
+            up->flag_buf_ptr = &up->flag_buf[0];
+        }
+        else
+        {
+            up->get_char_ptr = &up->char_buf[0];
+            up->get_flag_ptr = &up->flag_buf[0];
+            up->buf_num = 1;
+            up->char_buf_ptr = &up->char_buf[PERLE_SERIAL_DS_FLIPBUF_SIZE];
+            up->flag_buf_ptr = &up->flag_buf[PERLE_SERIAL_DS_FLIPBUF_SIZE];
+        }
+        up->get_count = up->count;
+        up->count = 0;
+//SVT   local_irq_restore(flags);
+		//spin_unlock_irqrestore(&port->lock, flags);
+
+
+        while ((up->get_count))
+        {
+            uart_insert_char(port,0,UART_LSR_OE,*up->get_char_ptr, *up->get_flag_ptr);
+            if (overrun!=port->icount.buf_overrun)
+            {
+                // trace_special(up, UTR_TTY_OVERRUN);
+                // inserting the byte into the tty buffer caused an overrun...
+                // try again later
+                break;
+            }
+            up->get_char_ptr++;
+            up->get_flag_ptr++;
+            up->get_count--;
+        }
+
+        if (up->get_count)
+        {
+            mod_timer(&up->forward_send_timer, jiffies + PERLE_SERIAL_FORWARD_SEND_TIMEOUT);
+        }
+
+        tty_flip_buffer_push(&up->port.state->port);
+
+    }
+#ifdef SERIAL_DEBUG_FORWARDING
+        printk("forward_frame: end, get count %d, count %d, number %d\n",up->get_count, up->count, up->buf_num);
+#endif
+}
+
+//
+// forward on idle character timeout
+//
+void serial8250_forward_idle_timer(struct timer_list *t)
+{
+    struct uart_8250_port *up = from_timer(up, t, forward_idle_timer);
+	unsigned long flags;
+// #ifdef SERIAL_DEBUG_FORWARDING
+//     printk("ps_forward_idle_timer: data = 0x%x\n", (unsigned int)data);
+// #endif
+	spin_lock_irqsave(&up->port.lock, flags);
+    forward_frame(up);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+}
+
+EXPORT_SYMBOL(serial8250_forward_idle_timer);
+
+//
+// force forward timeout
+//
+void serial8250_forward_force_timer(struct timer_list *t)
+{
+    struct uart_8250_port *up = from_timer(up, t, forward_force_timer);
+	unsigned long flags;
+// #ifdef SERIAL_DEBUG_FORWARDING
+//     printk("ps_forward_force_timer: data = 0x%x\n", (unsigned int)data);
+// #endif
+	spin_lock_irqsave(&up->port.lock, flags);
+    forward_frame(up);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+}
+
+EXPORT_SYMBOL(serial8250_forward_force_timer);
+
+//
+// forward delay send timeout
+//
+void serial8250_forward_send_timer(struct timer_list *t)
+{
+    struct uart_8250_port *up = from_timer(up, t, forward_send_timer);
+    struct uart_port *port = &up->port;
+    typeof(port->icount.buf_overrun) overrun=port->icount.buf_overrun;
+	 unsigned long flags;
+
+#ifdef SERIAL_DEBUG_FORWARDING
+    printk("ps_forward_send_timer: start, get count %d\n", up->get_count);
+#endif
+	spin_lock_irqsave(&port->lock, flags);
+
+    while ((up->get_count))
+    {
+        uart_insert_char(port,0,UART_LSR_OE,*up->get_char_ptr, *up->get_flag_ptr);
+        if (overrun!=port->icount.buf_overrun)
+        {
+            // inserting the byte into the tty buffer caused an overrun...
+            // try again later
+            break;
+        }
+        up->get_char_ptr++;
+        up->get_flag_ptr++;
+        up->get_count--;
+    }
+
+    if (up->get_count)
+    {
+        mod_timer(&up->forward_send_timer, jiffies + PERLE_SERIAL_FORWARD_SEND_TIMEOUT);
+    }
+	
+	spin_unlock_irqrestore(&port->lock, flags);
+
+    tty_flip_buffer_push(&up->port.state->port);
+#ifdef SERIAL_DEBUG_FORWARDING
+    printk("ps_forward_send_timer: end, get count %d\n",up->get_count);
+#endif
+}
+
+EXPORT_SYMBOL(serial8250_forward_send_timer);
+
+/*
+ * ===============================================
+ * Signal Scan routines
+ * ===============================================
+ */
+
+#define PROCSS_NONE 0
+#define PROCSS_SCAN 1
+#define PROCSS_START 2
+#define PROCSS_DELAY 3
+
+// events for fsmSigScan
+#define FSMSS_EXIT 0
+#define FSMSS_TIMEOUT 1
+#define FSMSS_SCAN 2
+#define FSMSS_TIOCM 3
+
+#ifdef SERIAL_DEBUG_SEND_SIGNAL
+static int send_signal_DEBUG(int pid, int sig, int priv, const char *func, int line)
+{
+	printk("send_signal(%d,%d,%d) caller: %s()@%d\n", pid, sig, priv, func, line);
+    return(kill_pid(find_vpid(pid), sig, priv));
+}
+#define send_signal(pid, sig, priv) send_signal_DEBUG(pid, sig, priv, __FUNCTION__, __LINE__)
+#else
+#define send_signal(pid, sig, priv) kill_pid(find_vpid(pid), sig, priv)
+#endif
+
+static unsigned short MSR2TIOCM(unsigned char msr)
+{
+    unsigned short tiocm = 0;
+
+    if (msr & UART_MSR_DSR)
+        tiocm |= TIOCM_DSR;
+    if (msr & UART_MSR_DCD)
+        tiocm |= TIOCM_CD;
+    if (msr & UART_MSR_CTS)
+        tiocm |= TIOCM_CTS;
+    if (msr & UART_MSR_RI)
+        tiocm |= TIOCM_RNG;
+    return(tiocm);
+}
+
+
+static void sigScanDefault(struct uart_8250_port *up)
+{
+	memset(&up->sigScan, 0, sizeof(struct sigscan));
+	up->sigScan.line = 0xffff;
+}
+
+static int fsmSigScan(struct uart_8250_port *up, int event, int data)
+{
+    int pid = up->sigScan.pid;
+//	struct uart_port *port = &up->port;	// SVT
+    int proc;
+
+
+    proc = getProcSigScan(up->sigScan.line);
+//  printk("%s()@%d: pid=%d line=%d event=%d data=%s proc=%d\n",__FUNCTION__,__LINE__, pid, up->sigScan.line, event, data, proc );
+    if(proc < 0)
+        return(-1);
+
+    switch(event)
+    {
+    case FSMSS_TIMEOUT:
+    case FSMSS_EXIT:
+        del_timer(&up->sigscan_delay_timer);
+        setProcSigScan(up->sigScan.line, PROCSS_NONE);
+        if(pid)
+            send_signal(pid, SIGUSR1, 1);
+        sigScanDefault(up);
+        break;
+    case FSMSS_SCAN:
+        setProcSigScan(up->sigScan.line, PROCSS_SCAN);
+        if(pid)
+            send_signal(pid, SIGUSR1, 1);
+        break;
+    case FSMSS_TIOCM:
+        if(pid == 0)
+            break;
+        switch(proc)
+        {
+        case PROCSS_SCAN:
+            if((data & up->sigScan.sigmask) == up->sigScan.sigmask)
+            {
+                setProcSigScan(up->sigScan.line, PROCSS_START);
+                send_signal(pid, SIGUSR1, 1);
+            }
+            break;
+        case PROCSS_START:
+            if((data & up->sigScan.sigmask) != up->sigScan.sigmask)
+            {
+                int delay = (up->sigScan.msec * HZ / 1000) + 1;
+
+                set_modem_info(up, TIOCMBIC, up->sigScan.sigdrop);
+                setProcSigScan(up->sigScan.line, PROCSS_DELAY);
+                send_signal(pid, SIGUSR1, 1);
+
+                if(up->forwarding & (DS_FORWARD_ON_TIME|DS_FORWARD_ON_IDLE|DS_FORWARD_ON_COUNT))
+                {
+                    unsigned long flags;
+
+                    local_irq_save(flags);
+// SVT oops					spin_lock_irqsave(&port->lock, flags);
+                    if(up->count != 0)
+                        forward_frame(up);  // send any data we are holding
+                    up->forwarding &= ~(DS_FORWARD_ON_TIME|DS_FORWARD_ON_IDLE|DS_FORWARD_ON_COUNT); // no more forwarding...
+                    local_irq_restore(flags);
+// SVT oops					spin_unlock_irqrestore(&port->lock, flags);
+                }
+
+                mod_timer(&up->sigscan_delay_timer, jiffies + delay);
+            }
+            break;
+        }
+        break;
+    default:
+        return(-1);
+    }
+
+    return(0);
+}
+
+//
+// signal scan delay timeout
+//
+void serial8250_sigscan_delay_timer(struct timer_list *t)
+{
+	unsigned long flags;
+    struct uart_8250_port *up = from_timer(up, t, sigscan_delay_timer);
+	struct uart_port *port = &up->port;
+	
+	spin_lock_irqsave(&port->lock, flags);
+    fsmSigScan(up, FSMSS_TIMEOUT, 0);
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+EXPORT_SYMBOL(serial8250_sigscan_delay_timer);
+// Perle end for trueport
 /* Uart divisor latch read */
 static u32 default_serial_dl_read(struct uart_8250_port *up)
 {
@@ -1509,7 +2891,9 @@ static inline void __stop_tx(struct uart_8250_port *p)
 
 		__stop_tx_rs485(p, stop_delay);
 	}
-
+// Perle start for trueport
+	p->port.rs485_txing_no_echo = 0;	// jic doing 485
+// Perle end for trueport
 	if (serial8250_clear_THRI(p))
 		serial8250_rpm_put_tx(p);
 }
@@ -1774,14 +3158,164 @@ u16 serial8250_rx_chars(struct uart_8250_port *up, u16 lsr)
 {
 	struct uart_port *port = &up->port;
 	int max_count = 256;
-
+// Perle start for trueport
+    char flag;
+    // uint8_t tracebuf[up->port.fifosize];
+    // int tracelen=0;
+    unsigned char ignore_this_byte=0;
+// Perle end for trueport
 	do {
-		serial8250_read_char(up, lsr);
+// Perle start for trueport
+int need_report = 0;
+
+unsigned char ignore_this_byte=0;
+            if(up->port.rs485_txing_no_echo)
+            {
+                break;
+            }
+// Perle end for trueport
+	u8 ch, flag = TTY_NORMAL;
+
+	if (likely(lsr & UART_LSR_DR))
+		ch = serial_in(up, UART_RX);
+	else
+		/*
+		 * Intel 82571 has a Serial Over Lan device that will
+		 * set UART_LSR_BI without setting UART_LSR_DR when
+		 * it receives a break. To avoid reading from the
+		 * receive buffer without UART_LSR_DR bit set, we
+		 * just force the read character to be 0
+		 */
+		ch = 0;
+    printk("(%s,%d):serial8250_read_char starting,ch = %c\n",__FUNCTION__,__LINE__, ch);
+	port->icount.rx++;
+
+	lsr |= up->lsr_saved_flags;
+	up->lsr_saved_flags = 0;
+
+	if (unlikely(lsr & UART_LSR_BRK_ERROR_BITS)) {
+		if (lsr & UART_LSR_BI) {
+			lsr &= ~(UART_LSR_FE | UART_LSR_PE);
+			port->icount.brk++;
+// Perle start for trueport
+// trace_special(up, UTR_RX_BREAK);
+// Perle end for trueport
+			/*
+			 * We do the SysRQ and SAK checking
+			 * here because otherwise the break
+			 * may get masked by ignore_status_mask
+			 * or read_status_mask.
+			 */
+			if (uart_handle_break(port))
+				break;
+// Perle start for trueport
+                if (up->rpt_lsrmask & UART_LSR_BI)
+                {
+                    up->rpt_LSR |= UART_LSR_BI;
+                    need_report = 1;
+                }
+// Perle end for trueport
+		} else if (lsr & UART_LSR_PE)
+        {// Perle start for trueport
+                // trace_special(up, UTR_PARITY);
+                if (up->port.rs485.flags & SER_RSXXX_IGNORE_LINE_ERRORS)
+                {
+                    ignore_this_byte=1;
+                }
+                else
+                {
+                    // Perle end for trueport
+                    port->icount.parity++;
+                    // Perle start for trueport
+                    up->rpt_LSR |= UART_LSR_PE;
+                    if (up->rpt_lsrmask & UART_LSR_PE)
+                    {
+                        need_report = 1;
+                    }
+                }
+            // Perle end for trueport
+        }
+			
+		else if (lsr & UART_LSR_FE)
+        {
+            // Perle start for trueport
+                if (up->port.rs485.flags & SER_RSXXX_IGNORE_LINE_ERRORS)
+                {
+                    ignore_this_byte=1;
+                }
+                else
+                {
+// Perle end for trueport
+			port->icount.frame++;
+            // Perle start for trueport
+                    up->rpt_LSR |= UART_LSR_FE;
+                    if (up->rpt_lsrmask & UART_LSR_FE)
+                    {
+                        need_report = 1;
+                    }
+                }
+// Perle end for trueport
+        }
+        if (lsr & UART_LSR_OE){
+
+			port->icount.overrun++;
+            // Perle start for trueport
+                // trace_special(up, UTR_OVERRUN);
+
+                up->rpt_LSR |= UART_LSR_OE;
+                if (up->rpt_lsrmask & UART_LSR_OE)
+                {
+                    need_report = 1;
+                }
+// Perle end for trueport
+        }
+		/*
+		 * Mask off conditions which should be ignored.
+		 */
+		lsr &= port->read_status_mask;
+
+		if (lsr & UART_LSR_BI) {
+			dev_dbg(port->dev, "handling break\n");
+			flag = TTY_BREAK;
+		} else if (lsr & UART_LSR_PE)
+			flag = TTY_PARITY;
+		else if (lsr & UART_LSR_FE)
+			flag = TTY_FRAME;
+	}
+	if (uart_prepare_sysrq_char(port, ch))
+		break;
+
+// Perle start for trueport
+        if (!ignore_this_byte)
+        {
+            push_char(up, lsr, UART_LSR_OE, ch, flag);
+
+            // if(up->traceMask & TRACE_BITS_IN)
+            // {
+            //     tracebuf[tracelen++]=ch;
+            //     if ((tracelen >= MAX_TRACE_DATA) || (tracelen >= sizeof(tracebuf)))
+            //     {
+            //         uartTraceAdd(up->tracePortIndex, TRACE_IN, tracelen, &tracebuf[0]);
+            //         tracelen=0;     // reset the trace buffer
+            //     }
+            // }
+
+            if ((up->rpt_mode == TRPT_ON) && (up->rpt_pid > 0) && need_report)
+                send_signal(up->rpt_pid, SIGUSR1, 1);
+        }
+
+
 		if (--max_count == 0)
 			break;
 		lsr = serial_in(up, UART_LSR);
-	} while (lsr & (UART_LSR_DR | UART_LSR_BI));
 
+	} while (lsr & (UART_LSR_DR | UART_LSR_BI));
+// Perle start for trueport
+    // if((up->traceMask & TRACE_BITS_IN) && tracelen)
+    // {
+    //     uartTraceAdd(up->tracePortIndex, TRACE_IN, tracelen, &tracebuf[0]);
+    // }
+// Perle end for trueport
 	tty_flip_buffer_push(&port->state->port);
 	return lsr;
 }
@@ -1793,24 +3327,160 @@ void serial8250_tx_chars(struct uart_8250_port *up)
 	struct circ_buf *xmit = &port->state->xmit;
 	int count;
 
+// Perle start for trueport
+    // int tracing=(up->traceMask & TRACE_BITS_OUT);
+    // uint8_t tracebuf[up->port.fifosize];
+    // int tracelen = 0;
+    int rts_toggle_delay;
+    int tmp_mcr;
+    int tmp_msr;
+// Perle end for trueport
 	if (port->x_char) {
-		uart_xchar_out(port, UART_TX);
-		return;
-	}
-	if (uart_tx_stopped(port)) {
-		serial8250_stop_tx(port);
-		return;
-	}
-	if (uart_circ_empty(xmit)) {
-		__stop_tx(up);
+        // Perle start for trueport
+        serial_port_out(port, UART_TX, port->x_char);
+		if(up->port.rs485.flags & SER_RS485_ECHO_SUPPRESSION)
+			up->port.rs485_txing_no_echo = 1;
+        // if(tracing)
+        //     uartTraceAdd(up->tracePortIndex, TRACE_OUT, 1, &up->port.x_char);
+
+        	port->icount.tx++;
+	        port->x_char = 0;
+		// uart_xchar_out(port, UART_TX);
+        // Perle end for trueport
 		return;
 	}
+// Perle start for trueport
 
+    if (!up->rs232_rts_toggle)
+    {
+		if (uart_tx_stopped(port)) {
+			serial8250_stop_tx(port);
+			return;
+		}
+		if (uart_circ_empty(xmit)) {
+			__stop_tx(up);
+			return;
+		}
+
+		if(up->port.rs485.flags & SER_RS485_ECHO_SUPPRESSION)
+			up->port.rs485_txing_no_echo = 1;
+
+    }
+	else
+	{
+#ifdef SERIAL_DEBUG_RTSTOGGLE
+        printk("(%s,%d): starting, RTS toggle enabled\n",__FUNCTION__,__LINE__);
+#endif
+        if (uart_circ_empty(xmit))
+        {
+#ifdef SERIAL_DEBUG_RTSTOGGLE
+            printk("(%s,%d): no data to send\n",__FUNCTION__,__LINE__);
+#endif
+            serial8250_stop_tx(&up->port);
+            tmp_mcr = serial_in(up, UART_MCR);
+            if (tmp_mcr & UART_MCR_RTS)
+            {
+                rts_toggle_delay = serial_in_UART_TXCNT(up);
+                if (rts_toggle_delay == 0)
+                    rts_toggle_delay = 1;
+                rts_toggle_delay *= up->rs232_rts_toggle_char_timeout * HZ / 1000;
+                if (up->rts_toggle_final_delay)
+                    rts_toggle_delay += up->rts_toggle_final_delay * HZ / 1000;
+                mod_timer(&up->rs232_rts_toggle_timer, jiffies + rts_toggle_delay);
+#ifdef SERIAL_DEBUG_RTSTOGGLE
+                printk("(%s,%d): buffer empty, set rs232_rts_toggle_timer, %d\n",__FUNCTION__,__LINE__,rts_toggle_delay);
+#endif
+            }
+            return;
+        }
+        else // have data to send
+        {
+#ifdef SERIAL_DEBUG_RTSTOGGLE
+            printk("(%s,%d): have data to send\n",__FUNCTION__,__LINE__);
+#endif
+            tmp_mcr = serial_in(up, UART_MCR);
+            if (!(tmp_mcr & UART_MCR_RTS))
+            {
+                tmp_mcr |= UART_MCR_RTS;
+				serial8250_out_MCR(up, tmp_mcr);
+
+#ifdef SERIAL_DEBUG_RTSTOGGLE
+                printk("(%s,%d: assert RTS\n",__FUNCTION__,__LINE__);
+#endif
+                tmp_msr = serial_in_msr(up);
+                if (!(tmp_msr & UART_MSR_CTS) || (up->rts_toggle_initial_delay))
+                {
+                    serial8250_stop_tx(&up->port);
+                    rts_toggle_delay = (up->rts_toggle_initial_delay+1) * HZ / 1000;
+                    mod_timer(&up->rs232_rts_toggle_initial_timer, jiffies + rts_toggle_delay);
+#ifdef SERIAL_DEBUG_RTSTOGGLE
+                    printk("(%s,%d): set rs232_rts_toggle_initial_timer, %d\n",__FUNCTION__,__LINE__,rts_toggle_delay);
+#endif
+                    return;
+                }
+            }
+            if (uart_tx_stopped(&up->port))
+            {
+                serial8250_stop_tx(&up->port);
+#ifdef SERIAL_DEBUG_RTSTOGGLE
+                printk("(%s,%d): tx stopped\n",__FUNCTION__,__LINE__);
+#endif
+                return;
+            }
+            if (timer_pending(&up->rs232_rts_toggle_initial_timer))
+            {
+                serial8250_stop_tx(&up->port);
+#ifdef SERIAL_DEBUG_RTSTOGGLE
+                printk("(%s,%d): rs232_rts_toggle_initial_timer is pending\n",__FUNCTION__,__LINE__);
+#endif
+                return;
+            }
+            if (timer_pending(&up->rs232_rts_toggle_timer))
+            {
+                del_timer(&up->rs232_rts_toggle_timer);
+#ifdef SERIAL_DEBUG_RTSTOGGLE
+                printk("(%s,%d): delete rs232_rts_toggle_timer\n",__FUNCTION__,__LINE__);
+#endif
+            }
+        }
+#ifdef SERIAL_DEBUG_RTSTOGGLE
+        printk("(%s,%d): tx chars, %d\n",__FUNCTION__,__LINE__,up->port.icount.tx);
+#endif
+    }
+
+
+
+	// if (uart_tx_stopped(port)) {
+	// 	serial8250_stop_tx(port);
+	// 	return;
+	// }
+	// if (uart_circ_empty(xmit)) {
+	// 	__stop_tx(up);
+	// 	return;
+	// }
+// Perle end for trueport
 	count = up->tx_loadsz;
 	do {
+        // Perle start for trueport
+            uint8_t ch;
+        ch=xmit->buf[xmit->tail];
+        // Perle end for trueport
 		serial_out(up, UART_TX, xmit->buf[xmit->tail]);
-		if (up->bugs & UART_BUG_TXRACE) {
+// Perle start for trueport
+        xmit->buf[xmit->tail] = 0;
+        // if (tracing)
+        // {
+        //     tracebuf[tracelen++]=ch;
+        //     if ((tracelen >= MAX_TRACE_DATA) || (tracelen >= sizeof(tracebuf)))
+        //     {
+        //         uartTraceAdd(up->tracePortIndex, TRACE_OUT, tracelen, &tracebuf[0]);
+        //         tracelen=0;     // reset the trace buffer
+        //     }
+        // }
+// Perle end for trueport
 			/*
+		if (up->bugs & UART_BUG_TXRACE) {
+
 			 * The Aspeed BMC virtual UARTs have a bug where data
 			 * may get stuck in the BMC's Tx FIFO from bursts of
 			 * writes on the APB interface.
@@ -1820,11 +3490,34 @@ void serial8250_tx_chars(struct uart_8250_port *up)
 			 * side-effects and discard the result.
 			 */
 			serial_in(up, UART_SCR);
-		}
+		
 		uart_xmit_advance(port, 1);
 		if (uart_circ_empty(xmit))
+        {
+            // Perle start for trueport
+
+#ifdef SERIAL_DEBUG_RTSTOGGLE
+            if (up->rs232_rts_toggle)
+                printk("(%s,%d): no more data to send\n",__FUNCTION__,__LINE__);
+#endif
+            tmp_mcr = serial_in(up, UART_MCR);
+            if ((up->rs232_rts_toggle) && (tmp_mcr & UART_MCR_RTS))
+            {
+                rts_toggle_delay = serial_in_UART_TXCNT(up);
+                if (rts_toggle_delay == 0)
+                    rts_toggle_delay = 1;
+                rts_toggle_delay *= up->rs232_rts_toggle_char_timeout * HZ / 1000;
+                if (up->rts_toggle_final_delay)
+                    rts_toggle_delay += up->rts_toggle_final_delay * HZ / 1000;
+                mod_timer(&up->rs232_rts_toggle_timer, jiffies + rts_toggle_delay);
+#ifdef SERIAL_DEBUG_RTSTOGGLE
+                printk("(%s,%d): no more data, set rs232_rts_toggle_timer, %d\n",__FUNCTION__,__LINE__,rts_toggle_delay);
+#endif
+            }
+            // Perle end for trueport
 			break;
-		if ((up->capabilities & UART_CAP_HFIFO) &&
+        }
+        if ((up->capabilities & UART_CAP_HFIFO) &&
 		    !uart_lsr_tx_empty(serial_in(up, UART_LSR)))
 			break;
 		/* The BCM2835 MINI UART THRE bit is really a not-full bit. */
@@ -1832,20 +3525,63 @@ void serial8250_tx_chars(struct uart_8250_port *up)
 		    !(serial_in(up, UART_LSR) & UART_LSR_THRE))
 			break;
 	} while (--count > 0);
-
+// Perle start for trueport
+    // if (tracing && tracelen)
+    // {
+    //     uartTraceAdd(up->tracePortIndex, TRACE_OUT, tracelen, &tracebuf[0]);
+    // }
+#ifdef SERIAL_DEBUG_RTSTOGGLE
+    if (up->rs232_rts_toggle)
+        printk("(%s,%d): done tx chars, %d\n",__FUNCTION__,__LINE__,up->port.icount.tx);
+#endif
+// Perle end for trueport
 	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+    {
+// Perle start for trueport
+#ifdef SERIAL_DEBUG_RTSTOGGLE
+        if (up->rs232_rts_toggle)
+            printk("(%s,%d): write wakeup\n",__FUNCTION__,__LINE__);
+#endif
+// Perle end for trueport
 		uart_write_wakeup(port);
-
+    }
 	/*
 	 * With RPM enabled, we have to wait until the FIFO is empty before the
 	 * HW can go idle. So we get here once again with empty FIFO and disable
 	 * the interrupt and RPM in __stop_tx()
 	 */
-	if (uart_circ_empty(xmit) && !(up->capabilities & UART_CAP_RPM))
-		__stop_tx(up);
+    // Perle start for trueport
+    if(!up->port.rs485_txing_no_echo)
+// Perle end for trueport
+    {
+	    if (uart_circ_empty(xmit) && !(up->capabilities & UART_CAP_RPM))
+		{
+            __stop_tx(up);
+        }
+    }
 }
 EXPORT_SYMBOL_GPL(serial8250_tx_chars);
+// Perle start for trueport
+void serial8250_signal_timer(struct timer_list *t)
+{
+    unsigned long flags;
+    struct uart_8250_port *up = from_timer(up, t, signal_timer);
+ 
+    struct uart_port *port = &up->port;
+
+    spin_lock_irqsave(&port->lock, flags);
+    if (up->signal_count > SIGNAL_TIMER_CNT_MAX)
+    {
+        up->ier |= UART_IER_MSI;
+        serial_port_out(port, UART_IER, up->ier);  /* enable interrupts */
+    }
+    up->signal_count = 0;
+    mod_timer(&up->signal_timer, jiffies + SIGNAL_TIMER_TM);
+    spin_unlock_irqrestore(&port->lock, flags);
+}
 
+EXPORT_SYMBOL(serial8250_signal_timer);
+// Perle end for trueport
 /* Caller holds uart port lock */
 unsigned int serial8250_modem_status(struct uart_8250_port *up)
 {
@@ -1854,6 +3590,24 @@ unsigned int serial8250_modem_status(struct uart_8250_port *up)
 
 	status |= up->msr_saved_flags;
 	up->msr_saved_flags = 0;
+// Perle start for trueport
+        if (!(up->mcr & UART_MCR_AFE))
+        {
+            up->signal_count++;
+            if (up->signal_count > SIGNAL_TIMER_CNT_MAX)
+            {
+                up->ier &= ~UART_IER_MSI;
+                serial_port_out(port, UART_IER, up->ier);  /* disable interrupts */
+            }
+        }
+        // Signal a task to report changes if the following occurs:
+        //  report mode is on, report PID is valid and the change (delta)
+        //  in signals fall within the signal mask.
+        if ((up->rpt_mode == TRPT_ON) && (up->rpt_pid > 0) && (up->rpt_sigmask & ((status & UART_MSR_ANY_DELTA) << 4)))
+			send_signal(up->rpt_pid, SIGUSR1, 1);
+
+        fsmSigScan(up, FSMSS_TIOCM, MSR2TIOCM((unsigned char)status));
+// Perle end for trueport
 	if (status & UART_MSR_ANY_DELTA && up->ier & UART_IER_MSI &&
 	    port->state != NULL) {
 		if (status & UART_MSR_TERI)
@@ -1903,6 +3657,7 @@ static bool handle_rx_dma(struct uart_8250_port *up, unsigned int iir)
  */
 int serial8250_handle_irq(struct uart_port *port, unsigned int iir)
 {
+
 	struct uart_8250_port *up = up_to_u8250p(port);
 	struct tty_port *tport = &port->state->port;
 	bool skip_rx = false;
@@ -2022,7 +3777,13 @@ unsigned int serial8250_do_get_mctrl(struct uart_port *port)
 	val = serial8250_MSR_to_TIOCM(status);
 	if (up->gpios)
 		return mctrl_gpio_get(up->gpios, &val);
-
+// Perle start for trueport
+    fix_port_mctrl_from_mcr(up);
+    // if(up->traceMask & TRACE_BITS_IOCTL)
+    // {
+    //     uartTraceAddIoctl(up->tracePortIndex, TIOCMGET);
+    // }
+// Perle end for trueport
 	return val;
 }
 EXPORT_SYMBOL_GPL(serial8250_do_get_mctrl);
@@ -2033,22 +3794,41 @@ static unsigned int serial8250_get_mctrl(struct uart_port *port)
 		return port->get_mctrl(port);
 	return serial8250_do_get_mctrl(port);
 }
-
+// Perle start for trueport
 void serial8250_do_set_mctrl(struct uart_port *port, unsigned int mctrl)
 {
-	struct uart_8250_port *up = up_to_u8250p(port);
-	unsigned char mcr;
+    struct uart_8250_port *up = up_to_u8250p(port);
+//	printkSVT(port, __LINE__);
 
-	mcr = serial8250_TIOCM_to_MCR(mctrl);
+    set_modem_info(up, TIOCMSET, mctrl);    // use set_modem_info instead to handle remapped DTR and RTS (using out1/out2)
+}
 
-	mcr |= up->mcr;
+// void serial8250_do_set_mctrl(struct uart_port *port, unsigned int mctrl)
+// {
+// 	struct uart_8250_port *up = up_to_u8250p(port);
+// 	unsigned char mcr;
 
-	serial8250_out_MCR(up, mcr);
-}
+// 	mcr = serial8250_TIOCM_to_MCR(mctrl);
+
+// 	mcr |= up->mcr;
+
+// 	serial8250_out_MCR(up, mcr);
+// }
+// Perle end for trueport
 EXPORT_SYMBOL_GPL(serial8250_do_set_mctrl);
 
 static void serial8250_set_mctrl(struct uart_port *port, unsigned int mctrl)
 {
+// Perle start for trueport
+    {
+        struct uart_8250_port *up = up_to_u8250p(port);
+
+        // if(up->traceMask & TRACE_BITS_IOCTL)
+        // {
+        //     uartTraceAddIoctl(up->tracePortIndex, TIOCMSET);
+        // }
+    }
+// Perle end for trueport
 	if (port->rs485.flags & SER_RS485_ENABLED)
 		return;
 
@@ -2064,6 +3844,12 @@ static void serial8250_break_ctl(struct uart_port *port, int break_state)
 	unsigned long flags;
 
 	serial8250_rpm_get(up);
+// Perle start for trueport
+    // if (break_state == -1)
+    // {
+    //     trace_special(up, UTR_TX_BREAK);
+    // }
+// Perle end for trueport
 	spin_lock_irqsave(&port->lock, flags);
 	if (break_state == -1)
 		up->lcr |= UART_LCR_SBC;
@@ -2135,6 +3921,15 @@ static int serial8250_get_poll_char(struct uart_port *port)
 	}
 
 	status = serial_port_in(port, UART_RX);
+// Perle start for trueport
+    {
+        if(port->rs485_txing_no_echo)
+        {
+            status = NO_POLL_CHAR;
+            goto out;
+        }
+    }
+// Perle end for trueport
 out:
 	serial8250_rpm_put(up);
 	return status;
@@ -2435,7 +4230,17 @@ int serial8250_do_startup(struct uart_port *port)
 	serial_port_in(port, UART_MSR);
 	up->lsr_saved_flags = 0;
 	up->msr_saved_flags = 0;
-
+// Perle start for trueport
+    up->forward_state = up->base_state;
+    up->char_buf_ptr = &up->char_buf[0];
+    up->flag_buf_ptr = &up->flag_buf[0];
+    up->count = 0;
+    up->buf_num = 0;
+    up->get_count = 0;
+    mod_timer(&up->signal_timer, jiffies + SIGNAL_TIMER_TM);
+    up->signal_count = 0;  
+    sigScanDefault(up);
+// Perle end for trueport
 	/*
 	 * Request DMA channels for both RX and TX.
 	 */
@@ -2510,8 +4315,14 @@ void serial8250_do_shutdown(struct uart_port *port)
 		port->mctrl |= TIOCM_OUT1;
 	} else
 		port->mctrl &= ~TIOCM_OUT2;
-
+// Perle start for trueport
+	port->mctrl &= ~(TIOCM_DTR|TIOCM_RTS);
 	serial8250_set_mctrl(port, port->mctrl);
+	if(up->port.rs485_txing_no_echo)
+		flush_rx(up);
+	// transceiverEnable(port, SERIAL_8250_MEDIA_TYPE_TRISTATE);
+// serial8250_set_mctrl(port, port->mctrl);
+// Perle end for trueport
 	spin_unlock_irqrestore(&port->lock, flags);
 
 	/*
@@ -2533,6 +4344,29 @@ void serial8250_do_shutdown(struct uart_port *port)
 	 * the IRQ chain.
 	 */
 	serial_port_in(port, UART_RX);
+// Perle start for trueport
+	spin_lock_irqsave(&port->lock, flags);
+
+    up->rpt_LSR = 0;
+    up->rpt_mode = 0;
+    up->rpt_pid = 0;
+    up->rpt_sigmask = 0;
+    up->rpt_lsrmask = 0;
+    up->port.drain_flag=0;
+	up->rs232_rts_toggle = 0;
+	
+	spin_unlock_irqrestore(&port->lock, flags);
+
+    del_timer_sync(&up->forward_idle_timer);
+    del_timer_sync(&up->forward_force_timer);
+    del_timer_sync(&up->forward_send_timer);
+    del_timer_sync(&up->rs232_rts_toggle_timer);
+    del_timer_sync(&up->rs232_rts_toggle_initial_timer);
+    fsmSigScan(up, FSMSS_EXIT, 0);
+    up->forwarding = 0;
+	
+    del_timer_sync(&up->signal_timer);
+// Perle end for trueport
 	serial8250_rpm_put(up);
 
 	up->ops->release_irq(up);
@@ -2850,9 +4684,12 @@ serial8250_do_set_termios(struct uart_port *port, struct ktermios *termios,
 	/*
 	 * CTS flow control flag and modem status interrupts
 	 */
-	up->ier &= ~UART_IER_MSI;
-	if (!(up->bugs & UART_BUG_NOMSR) &&
-			UART_ENABLE_MS(&up->port, termios->c_cflag))
+// Perle start for trueport
+
+	// up->ier &= ~UART_IER_MSI;
+	// if (!(up->bugs & UART_BUG_NOMSR) &&
+	// 		UART_ENABLE_MS(&up->port, termios->c_cflag))
+// Perle end for trueport
 		up->ier |= UART_IER_MSI;
 	if (up->capabilities & UART_CAP_UUE)
 		up->ier |= UART_IER_UUE;
@@ -3176,6 +5013,278 @@ static ssize_t rx_trig_bytes_store(struct device *dev,
 
 static DEVICE_ATTR_RW(rx_trig_bytes);
 
+// Perle start for trueport
+#define send_signal(pid, sig, priv) kill_pid(find_vpid(pid), sig, priv)
+typedef struct
+{
+    unsigned int cmd;
+    char *cmd_str;
+} perle_ioctl_t;
+
+perle_ioctl_t perle_ioctl[]={
+        {TCGETS,        "TCGETS"},
+        {TCSETS,        "TCSETS"},
+        {TCSETSW,       "TCSETSW"},
+        {TCFLSH,        "TCFLSH"},
+        {TIOCGRS485,    "TIOCGRS485"},
+        {TIOCSRS485,    "TIOCSRS485"},
+        {TRPTSET,       "TRPTSET"},
+        {TRPTGET,       "TRPTGET"},
+        {TRPTGETRST,    "TRPTGETRST"},
+        {TRPTSETPID,    "TRPTSETPID"},
+        {TIOCSERDS,     "TIOCSERDS"},
+        {TIOCFWDDS,     "TIOCFWDDS"},
+        {TIOCMAPDTR,    "TIOCMAPDTR"},
+        {TIOCMAPRTS,    "TIOCMAPRTS"},
+        {TRACECONTROL,  "TRACECONTROL"},
+        {TRACEREAD,     "TRACEREAD"},
+        {TIOCOSARMDS,   "TIOCOSARMDS"},
+        {TRESETCOUNT,   "TRESETCOUNT"},
+        {TSIGSCAN,      "TSIGSCAN"},
+        {TIOCCICOUNT,   "TIOCCICOUNT"},
+        {TRTSCONTROL,   "TRTSCONTROL"},
+        {TCSETS2,       "TCSETS2"},
+		{TIOCSLEEP,		"TIOCSLEEP"},
+        {0x5600,        "VT_OPENQRY"},  // VT_OPENQRY. hardcode to 0x5600 so I don't need to include vt.h just for this debug stuff
+        {0,""},
+};
+
+static int trptset_handler(struct uart_port *port,unsigned long arg)
+{
+    struct uart_8250_port *up = up_to_u8250p(port);
+    int returnCode=0;
+
+    if (up->rpt_pid > 0)
+    {
+        unsigned short user_sigmask;
+
+        if ((arg & ~0xf0000000) == 0)
+        {
+            up->rpt_mode = TRPT_OFF;
+        }
+        else
+        {
+            up->rpt_mode = TRPT_ON;
+        }
+        user_sigmask = 0xffff & arg;
+        up->rpt_user_sigmask = user_sigmask;
+        up->rpt_sigmask =  ((user_sigmask & TIOCM_CD) ? UART_MSR_DCD : 0)
+                  | ((user_sigmask & TIOCM_RI) ? UART_MSR_RI : 0)
+                  | ((user_sigmask & TIOCM_DSR) ? UART_MSR_DSR : 0)
+                  | ((user_sigmask & TIOCM_CTS) ? UART_MSR_CTS : 0);
+        up->rpt_lsrmask = 0xffff & (arg >> 16);
+		send_signal(up->rpt_pid, SIGUSR1, 1);
+    }
+    else
+    {
+        returnCode=(-EIO);
+    }
+    return(returnCode);
+}
+
+static int trptget_handler(struct uart_port *port,unsigned long arg, int reset)
+{
+    struct uart_8250_port *up = up_to_u8250p(port);
+    struct ttyrpt *rpt_user;
+    unsigned short rpt_signals;
+    int returnCode=0;
+
+    unsigned int MSR = serial_in_msr(up);
+    unsigned int MCR = serial_in(up,UART_MCR);
+
+    do
+    {
+        rpt_user = (struct ttyrpt *) arg;
+        returnCode = put_user(up->rpt_user_sigmask, &rpt_user->sigmask);
+        if (returnCode)
+        {
+            break;
+        }
+        returnCode = put_user(up->rpt_lsrmask, &rpt_user->lsrmask);
+        if (returnCode)
+        {
+            break;
+        }
+        rpt_signals =  ((MSR & UART_MSR_DCD) ? TIOCM_CD : 0)
+                | ((MSR & UART_MSR_RI) ? TIOCM_RI : 0)
+                | ((MSR & UART_MSR_DSR) ? TIOCM_DSR : 0)
+                | ((MSR & UART_MSR_CTS) ? TIOCM_CTS : 0)
+                | ((MCR & UART_MCR_RTS) ? TIOCM_RTS : 0)
+                | ((MCR & UART_MCR_DTR) ? TIOCM_DTR : 0);
+        returnCode = put_user(rpt_signals, &rpt_user->signals);
+        if (returnCode)
+        {
+            break;
+        }
+        returnCode = put_user(up->rpt_LSR, &rpt_user->lsr);
+        if (returnCode)
+        {
+            break;
+        }
+        if (reset)
+        {
+            up->rpt_LSR = 0;
+        }
+    } while(0);
+    return(returnCode);
+}
+
+static void trptsetpid_handler(struct uart_port *port,unsigned long arg)
+{
+    struct uart_8250_port *up = up_to_u8250p(port);
+
+    if ( arg > 0)
+    {
+        up->rpt_pid = arg;
+    }
+    else
+    {
+        up->rpt_pid = 0;
+        up->rpt_mode = TRPT_OFF;
+        up->rpt_sigmask = 0;
+        up->rpt_user_sigmask = 0;
+        up->rpt_lsrmask = 0;
+        up->rpt_LSR = 0;
+    }
+}
+
+
+static int perle_set_forwarding(struct uart_port *port, unsigned long arg)
+{
+    struct uart_8250_port *up = up_to_u8250p(port);
+    struct fwdpkt *new_forward_config=(struct fwdpkt *)arg;
+    unsigned long flags;
+    struct fwdpkt forward_config;
+
+    if (copy_from_user(&forward_config,new_forward_config,sizeof(forward_config)))
+        return -EFAULT;
+
+//SVT    local_irq_save(flags);
+	spin_lock_irqsave(&port->lock, flags);
+
+    up->forwarding = forward_config.forwarding;
+    up->start_transmit_rule = forward_config.start_transmit_rule;
+    up->end_transmit_rule = forward_config.end_transmit_rule;
+    up->packet_size = forward_config.packet_size;
+    up->idle_time = forward_config.idle_time;
+    up->force_time = forward_config.force_time;
+    up->trigger_char1 = forward_config.trigger_char1;
+    up->trigger_char2 = forward_config.trigger_char2;
+    up->start_frame1 = forward_config.start_frame1;
+    up->start_frame2 = forward_config.start_frame2;
+    up->end_frame1 = forward_config.end_frame1;
+    up->end_frame2 = forward_config.end_frame2;
+    up->oneshot_config = up->oneshot_forwarding = forward_config.oneshot_config;
+    up->direct_trigger = forward_config.direct_trigger;
+
+    if (up->forwarding & (DS_FORWARD_START_CHAR1|DS_FORWARD_START_CHAR2))
+    {
+        if (up->forwarding & DS_FORWARD_START_CHAR2)
+        {
+            up->forward_state = PERLE_SERIAL_FORWARD_STATE_START_1OF2;
+            up->base_state = PERLE_SERIAL_FORWARD_STATE_START_1OF2;
+        }
+        else
+        {
+            up->forward_state = PERLE_SERIAL_FORWARD_STATE_START_1OF1;
+            up->base_state = PERLE_SERIAL_FORWARD_STATE_START_1OF1;
+        }
+    }
+    else if (up->forwarding & (DS_FORWARD_ON_CHAR1|DS_FORWARD_ON_CHAR2))
+    {
+        if (up->forwarding & DS_FORWARD_ON_CHAR2)
+        {
+            up->forward_state = PERLE_SERIAL_FORWARD_STATE_END_1OF2;
+            up->base_state = PERLE_SERIAL_FORWARD_STATE_END_1OF2;
+        }
+        else
+        {
+            up->forward_state = PERLE_SERIAL_FORWARD_STATE_END_1OF1;
+            up->base_state = PERLE_SERIAL_FORWARD_STATE_END_1OF1;
+        }
+    }
+
+//SVT    local_irq_restore(flags);
+	spin_unlock_irqrestore(&port->lock, flags);
+
+#ifdef SERIAL_DEBUG_FORWARDING
+    printk( "perle_set_forwarding ttyPS%d: Processing ioctl TIOCFWDDS\n", up->port.line);
+    printk( "perle_set_forwarding: forwarding 0x%x, start rule 0x%x, end rule 0x%x, packet size %d\n",up->forwarding,up->start_transmit_rule,up->end_transmit_rule,up->packet_size);
+    printk( "                      idle time %d, force time %d, trigger 1 0x%x, trigger 2 0x%x\n",up->idle_time,up->force_time,up->trigger_char1,up->trigger_char2);
+    printk( "                      frame start 1 0x%x, start 2 0x%x, end 1 0x%x, end 2 0x%x\n",up->start_frame1,up->start_frame2,up->end_frame1,up->end_frame2);
+#endif
+
+    return 0;
+}
+
+static int perle_set_rts_toggle(struct uart_port *port, unsigned long arg)
+{
+    struct uart_8250_port *up = up_to_u8250p(port);
+    struct rts_control *new_rts_toggle_config=(struct rts_control *)arg;
+    unsigned long flags;
+    struct rts_control rts_toggle_config;
+
+    if (copy_from_user(&rts_toggle_config,new_rts_toggle_config,sizeof(rts_toggle_config)))
+        return -EFAULT;
+
+//SVT    local_irq_save(flags);
+	spin_lock_irqsave(&port->lock, flags);
+
+    if (rts_toggle_config.flags & RTS_TOGGLE_ON)
+        up->rs232_rts_toggle = 1;
+    else
+        up->rs232_rts_toggle = 0;
+
+    up->rts_toggle_initial_delay = rts_toggle_config.initial_delay;
+    up->rts_toggle_final_delay = rts_toggle_config.final_delay;
+
+//SVT    local_irq_restore(flags);
+	spin_unlock_irqrestore(&port->lock, flags);
+
+#ifdef SERIAL_DEBUG_RTSTOGGLE
+    printk( "perle_set_rts_toggle ttyPS%d: Processing ioctl TRTSCONTROL\n", up->port.line);
+    printk( "perle_set_rts_toggle: flag 0x%x, initial delay %d, final delay %d\n",up->rs232_rts_toggle,up->rts_toggle_initial_delay,up->rts_toggle_final_delay);
+#endif
+
+    return 0;
+}
+
+static int serial8250_ioctl(struct uart_port *port, unsigned int cmd, unsigned long arg)
+{
+    int ret = 0;
+
+    switch(cmd)
+    {
+        case TRPTSET:
+            ret=trptset_handler(port,arg);
+            break;
+        case TRPTGET:
+            ret=trptget_handler(port,arg,0);    // no reset
+            break;
+
+        case TRPTGETRST:
+            ret=trptget_handler(port,arg,1);    // with reset
+            break;
+
+        case TRPTSETPID:
+            trptsetpid_handler(port,arg);
+            break;
+
+        case TIOCFWDDS:
+            ret=perle_set_forwarding(port,arg);
+            break;
+
+        case TRTSCONTROL:
+            ret=perle_set_rts_toggle(port,arg);
+            break;
+
+        default:
+            ret=(-ENOIOCTLCMD);
+            break;
+    }
+    return ret;
+}
+// Perle end for trueport
 static struct attribute *serial8250_dev_attrs[] = {
 	&dev_attr_rx_trig_bytes.attr,
 	NULL
@@ -3271,6 +5380,9 @@ static const struct uart_ops serial8250_pops = {
 	.poll_get_char = serial8250_get_poll_char,
 	.poll_put_char = serial8250_put_poll_char,
 #endif
+// Perle start for trueport
+	.ioctl=serial8250_ioctl,
+// Perle end for trueport
 };
 
 void serial8250_init_port(struct uart_8250_port *up)
diff --git a/drivers/tty/serial/Makefile b/drivers/tty/serial/Makefile
index 138abbc89738..432fd9a98edb 100644
--- a/drivers/tty/serial/Makefile
+++ b/drivers/tty/serial/Makefile
@@ -23,7 +23,9 @@ obj-$(CONFIG_SERIAL_21285) += 21285.o
 
 # Now bring in any enabled 8250/16450/16550 type drivers.
 obj-y += 8250/
-
+# Perle start for trueport
+obj-y += uart_trace.o
+# Perle end for trueport
 obj-$(CONFIG_SERIAL_AMBA_PL010) += amba-pl010.o
 obj-$(CONFIG_SERIAL_AMBA_PL011) += amba-pl011.o
 obj-$(CONFIG_SERIAL_CLPS711X) += clps711x.o
diff --git a/drivers/tty/serial/serial_core.c b/drivers/tty/serial/serial_core.c
index 8ff0efac6aa0..847188a7cc61 100644
--- a/drivers/tty/serial/serial_core.c
+++ b/drivers/tty/serial/serial_core.c
@@ -33,7 +33,8 @@
 #include <linux/uaccess.h>
 
 #include "serial_base.h"
-
+#include <linux/uart_trace.h>
+#include <linux/serial_8250.h>
 /*
  * This is used to lock changes in serial line configuration.
  */
@@ -656,7 +657,17 @@ static unsigned int uart_chars_in_buffer(struct tty_struct *tty)
 	unsigned int ret;
 
 	port = uart_port_lock(state, flags);
-	ret = uart_circ_chars_pending(&state->xmit);
+// Perle start for trueport
+	if (state->uart_port->drain_flag)
+	{
+	    ret=0;
+	}
+	else
+	{
+		ret = uart_circ_chars_pending(&state->xmit);
+	}
+	// ret = uart_circ_chars_pending(&state->xmit);
+// Perle end for trueport
 	uart_port_unlock(port, flags);
 	return ret;
 }
@@ -1593,6 +1604,16 @@ uart_ioctl(struct tty_struct *tty, unsigned int cmd, unsigned long arg)
 	void __user *uarg = (void __user *)arg;
 	int ret = -ENOIOCTLCMD;
 
+// Perle start for trueport
+    {
+        struct uart_port *uport = uart_port_check(state);
+
+        if (!!uport && uport->ops->uart_trace_add_ioctl)
+        {
+            uport->ops->uart_trace_add_ioctl(uport, cmd);
+        }
+    }
+// Perle end for trueport
 
 	/*
 	 * These ioctls don't rely on the hardware to be present.
@@ -1830,6 +1851,13 @@ static void uart_wait_until_sent(struct tty_struct *tty, int timeout)
 		uart_port_deref(port);
 		return;
 	}
+// Perle start for trueport
+    if(port->drain_flag)
+    {
+		uart_port_deref(port);
+        return;
+    }
+// Perle end for trueport
 
 	/*
 	 * Set the check interval to be 1/5 of the estimated time to
@@ -3137,6 +3165,9 @@ static const struct attribute_group tty_dev_attr_group = {
 	.attrs = tty_dev_attrs,
 };
 
+// Perle start for trueport
+int setProcSigScan(int dsline, int state);
+// Perle end for trueport
 /**
  * serial_core_add_one_port - attach a driver-defined port structure
  * @drv: pointer to the uart low level driver structure for this port
@@ -3184,6 +3215,13 @@ static int serial_core_add_one_port(struct uart_driver *drv, struct uart_port *u
 		ret = -ENOMEM;
 		goto out;
 	}
+// Perle start for trueport
+	/*
+	 * save the major # for the device
+	 * we need it for sigscan
+	 */
+	uport->major = drv->major;
+// Perle end for trueport
 
 	/*
 	 * If this port is in use as a console then the spinlock is already
@@ -3226,6 +3264,9 @@ static int serial_core_add_one_port(struct uart_driver *drv, struct uart_port *u
 		dev_err(uport->dev, "Cannot register tty device on line %d\n",
 		       uport->line);
 	}
+// Perle start for trueport
+setProcSigScan(uport->line, 0);
+// Perle end for trueport
 
  out:
 	mutex_unlock(&port->mutex);
diff --git a/drivers/tty/serial/uart_trace.c b/drivers/tty/serial/uart_trace.c
new file mode 100644
index 000000000000..80cc27e6a139
--- /dev/null
+++ b/drivers/tty/serial/uart_trace.c
@@ -0,0 +1,372 @@
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial.h>
+#include <linux/major.h>
+#include <linux/string.h>
+#include <linux/fcntl.h>
+#include <linux/ptrace.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/miscdevice.h>
+#include <asm/uaccess.h>
+#include <asm/irq.h>
+#include <linux/serial_reg.h>
+#include <linux/uart_trace.h>
+
+static UartTrace *pUT = NULL;
+
+
+
+
+
+
+
+// convert ktime_t to microseconds
+static unsigned long getMicroSeconds(ktime_t ktime_val)
+{
+    return((unsigned long)ktime_to_us(ktime_val));
+}
+
+
+static ktime_t getMicroTicks(void)
+{
+    return(ktime_get());
+}
+
+static void getCompressedElapsed(unsigned short *pUtime)
+{
+	unsigned long now, jdiff, us, exp;
+	ktime_t ktime_now,ktime_diff;
+	
+	ktime_now = getMicroTicks();
+	ktime_diff = ktime_sub(ktime_now,pUT->microticks);
+	pUT->microticks = ktime_now;
+	
+	now = jiffies;
+	jdiff = now - pUT->jiffies;
+	pUT->jiffies = now;
+	
+	exp = 0;
+	if(jdiff >= HZ)							// 1+ seconds have passed by..
+	{
+		for(;jdiff > 4294UL; exp++)			// make sure nothing overflows
+			jdiff = jdiff >> 1;
+		us = (1000000UL * jdiff)/(unsigned long)HZ;
+	}
+	else
+	{
+		us = getMicroSeconds(ktime_diff);
+	}
+	
+	for(;us > (1 << UTIME_MANTISSA_BITS); exp++)
+		us = us >> 1;
+	
+	*pUtime = (exp << UTIME_MANTISSA_BITS) | us;
+}
+
+static int putData(TraceFifo *pF, char *pData, int dlen)
+{
+	int blen, need;
+	char *pBuf = pF->pBuf;
+
+	if(pF->end >= pF->start)
+		blen = pF->end -pF->start;
+	else
+		blen = pF->len -pF->start +pF->end;
+	
+	need = blen + dlen - pF->len;		// needed room
+//	if(need >= 0 && (pF->options & TRACE_OPTIONS_STOP))
+//		return(-1);						// exit time
+	
+	while(need >= 0)					// if not enough room
+	{
+		int slen = ((int)pBuf[pF->start] & 0xff) +1; // get start entry length
+		
+		pF->start += slen;				// move start pointer
+		if(pF->start >= pF->len)
+			pF->start -= pF->len;
+		need -= slen;
+	}
+	
+	if(pF->len - pF->end <= dlen)		// end of buffer copy
+	{
+		int mlen = pF->len -pF->end;
+		memcpy(&pBuf[pF->end], pData, mlen);
+		pF->end = 0;					// new end pointer
+		dlen -= mlen;					// move this much more
+		pData += mlen;					// this pointer
+	}
+	
+	if(dlen)
+	{
+		memcpy(&pBuf[pF->end], pData, dlen);
+		pF->end += dlen;				// this won't wrap
+	}
+
+	return(dlen);
+}
+
+static int copy_to_user_FifoRead(TraceRead *pTR, TraceFifo *pF)
+{
+	int blen, clen, dlen, rmax;
+	TraceRead tLocal;
+	char *pSrc;
+	char *pDst = (char *)pTR;
+	char *pBuf = pF->pBuf;
+	char *pEnd = &pBuf[pF->len];
+	
+	if(pF->end >= pF->start)
+		blen = pF->end -pF->start;
+	else
+		blen = pF->len -pF->start +pF->end;
+	
+	dlen = 0;
+	
+	if(blen)
+	{
+		// lets run through the records to see how many we can copy
+		for(rmax = pUT->readLength, pSrc = &pBuf[pF->start]; blen; )
+		{
+			int elen = ((int)*pSrc & 0xff) +1;	// copy one entry at a time
+			int rlen = rmax - dlen;				// remaining length to copy
+			
+			if(elen > rlen)						// too big for copy
+				break;
+			
+			dlen += elen;
+			blen -= elen;
+			
+			clen = pEnd - pSrc;					// can copy this much first
+			if(clen <= elen)					// copy in two parts
+			{
+				elen -= clen;
+				pSrc = pF->pBuf;
+			}
+			if(elen)
+			{
+				pSrc += elen;
+			}
+		}
+	}
+	
+	tLocal.dataLen = dlen;
+	tLocal.remLen = blen;
+	if (copy_to_user(pDst, &tLocal, sizeof(TraceRead)))
+	{
+		return -EFAULT;
+	}
+	pDst += sizeof(TraceRead);
+	
+	if(dlen)
+	{
+		pSrc = &pBuf[pF->start];				// start copy from here
+		clen = pF->len -pF->start;				// can copy this much first
+		if(clen <= dlen)
+		{
+			dlen -= clen;
+			if (copy_to_user(pDst, pSrc, clen))
+            {
+                return -EFAULT;
+            }
+			pDst += clen;
+			pSrc = pF->pBuf;
+			pF->start = 0;
+		}
+		if(dlen)
+		{
+			if (copy_to_user(pDst, pSrc, dlen))
+            {
+                return -EFAULT;
+            }
+			pF->start += dlen;
+		}
+	}
+	return(0);	
+}
+
+static unsigned long uartTraceStartJiffies;
+
+int uartTraceStart(int readLength)
+{
+	unsigned long flags;
+	UartTrace *pAlloc;
+	unsigned short utime;
+	unsigned long now = jiffies;
+	
+	if(readLength == 0)
+		return(0);
+	if(!pUT)
+    {
+        pAlloc = (UartTrace *)kmalloc(sizeof(UartTrace), GFP_ATOMIC);
+        if(pAlloc == NULL)
+            return(-ENOMEM);
+        memset(pAlloc, 0, sizeof(UartTrace));
+        pAlloc->fifo.pBuf = pAlloc->data;
+        pAlloc->fifo.len = UART_TRACE_LENGTH;
+		uartTraceStartJiffies = 0;
+    }
+    else
+    {
+        pAlloc = pUT;
+    }
+	
+	// Fix small problem when starting multiple port traces at once...
+	if(now < uartTraceStartJiffies || now > (uartTraceStartJiffies + HZ))
+    pAlloc->fifo.start = pAlloc->fifo.end = 0;
+
+	pAlloc->readLength = readLength;
+	uartTraceStartJiffies = now;
+	
+	local_irq_save(flags);
+	pUT = pAlloc;
+    getCompressedElapsed(&utime);
+	local_irq_restore(flags);
+	
+	return(0);
+}
+EXPORT_SYMBOL(uartTraceStart);
+
+int uartTraceRead(TraceRead *pTR)
+{
+	unsigned long flags;
+	
+	if(pUT == NULL)
+		return(-EACCES);
+	
+	local_irq_save(flags);
+	copy_to_user_FifoRead(pTR, &pUT->fifo);
+	local_irq_restore(flags);
+	
+	return(0);
+}
+EXPORT_SYMBOL(uartTraceRead);
+
+static int uartTraceAddHelper(int port, int type, int len, const char *pData)
+{
+	int elen;
+	unsigned long flags;
+	TraceEntry entry;
+	
+	if(len > MAX_TRACE_DATA || pUT == NULL)
+	{
+	    pr_err("(%s,%s,%d): len (%d) exceeds the maximum allowed (%d)...ignoring\n",__FILE__,__FUNCTION__,__LINE__,len, MAX_TRACE_DATA);
+		return(-1);
+	}
+	elen = sizeof(TraceEntry) - MAX_TRACE_DATA + len;
+	entry.len = (unsigned char)(elen -1);
+	entry.type = (unsigned char)type;
+	entry.port = (unsigned char)port;
+	memcpy(entry.data, pData, len);
+	
+	local_irq_save(flags);
+	getCompressedElapsed(&entry.utime);
+	putData(&pUT->fifo, (char *)&entry, elen);
+	local_irq_restore(flags);
+	
+	return(elen);
+}
+
+/*
+ * returns: total # of bytes used in the trace buffer (including the TraceEntry header (5 bytes).
+ */
+int uartTraceAdd(int port, int type, int len, const unsigned char *pData)
+{
+    int ret_len=0;
+    int len_to_process=0;
+    int index_to_process=0;
+    int status;
+
+    while(len)
+    {
+        if (len > MAX_TRACE_DATA)
+        {
+            len_to_process=MAX_TRACE_DATA;
+        }
+        else
+        {
+            len_to_process=len;
+        }
+        status=uartTraceAddHelper(port,type,len_to_process,&pData[index_to_process]);
+        if (status < 0)
+        {
+            ret_len=status;
+            break;
+        }
+        len-=len_to_process;
+        index_to_process+=len_to_process;
+        ret_len+=status;
+    }
+    return(ret_len);
+}
+EXPORT_SYMBOL(uartTraceAdd);
+
+int uartTraceAddSignals(int port, int *pSignals, int MCR, int MSR)
+{
+	int signals, retc;
+	
+	retc=0;
+	signals =  ((MCR & UART_MCR_RTS) ? TIOCM_RTS : 0)
+		| ((MCR & UART_MCR_DTR) ? TIOCM_DTR : 0)
+		| ((MCR & UART_MCR_OUT1) ? TIOCM_OUT1 : 0)
+		| ((MCR & UART_MCR_OUT2) ? TIOCM_OUT2 : 0)
+		| ((MSR  & UART_MSR_DCD) ? TIOCM_CAR : 0)
+		| ((MSR  & UART_MSR_RI) ? TIOCM_RNG : 0)
+		| ((MSR  & UART_MSR_DSR) ? TIOCM_DSR : 0)
+		| ((MSR  & UART_MSR_CTS) ? TIOCM_CTS : 0);
+		
+	if(*pSignals != signals)
+	{
+		retc = uartTraceAdd(port, TRACE_SIGNALS, sizeof(signals), (char *)&signals);
+		*pSignals = signals;
+	}
+	return(retc);
+}
+EXPORT_SYMBOL(uartTraceAddSignals);
+
+int uartTraceAddSignalsTIOCM(int port, int *pSignals, int MCR, int MSR)
+{
+    int signals, retc;
+
+    retc=0;
+    signals = (MCR & (TIOCM_RTS | TIOCM_DTR | TIOCM_OUT1 | TIOCM_OUT2)) |
+              (MSR & (TIOCM_CAR | TIOCM_RNG | TIOCM_DSR | TIOCM_CTS));
+
+    if(*pSignals != signals)
+    {
+        retc = uartTraceAdd(port, TRACE_SIGNALS, sizeof(signals), (char *)&signals);
+        *pSignals = signals;
+    }
+    return(retc);
+}
+EXPORT_SYMBOL(uartTraceAddSignalsTIOCM);
+
+
+int uartTraceAddSpecial(int port, short sp)
+{
+	return(uartTraceAdd(port, TRACE_SPECIAL, sizeof(sp), (char *)&sp));
+}
+EXPORT_SYMBOL(uartTraceAddSpecial);
+
+int uartTraceAddIoctl(int port, int ioctl)
+{
+    if(ioctl == TRACEREAD)  // don't fill up the trace with myself please
+    {
+        return(0);
+    }
+    else
+    {
+	return(uartTraceAdd(port, TRACE_IOCTL, sizeof(ioctl), (char *)&ioctl));
+    }
+}
+EXPORT_SYMBOL(uartTraceAddIoctl);
+
+
+
diff --git a/drivers/tty/tty_ldisc.c b/drivers/tty/tty_ldisc.c
index d80e9d4c974b..9bb08304bfe3 100644
--- a/drivers/tty/tty_ldisc.c
+++ b/drivers/tty/tty_ldisc.c
@@ -660,15 +660,24 @@ int tty_ldisc_reinit(struct tty_struct *tty, int disc)
 		tty_ldisc_close(tty, tty->ldisc);
 		tty_ldisc_put(tty->ldisc);
 	}
-
-	/* switch the line discipline */
-	tty->ldisc = ld;
-	tty_set_termios_ldisc(tty, disc);
-	retval = tty_ldisc_open(tty, tty->ldisc);
-	if (retval) {
-		tty_ldisc_put(tty->ldisc);
-		tty->ldisc = NULL;
-	}
+// Perle start for trueport
+ 	tty_set_termios_ldisc(tty, disc);
+	retval = tty_ldisc_open(tty, ld);
+ 	if (retval) {
+ 		if (!WARN_ON(disc == N_TTY)) {
+			tty_ldisc_put(ld);
+			ld = NULL;
+ 		}
+ 	}
+	// /* switch the line discipline */
+	// tty->ldisc = ld;
+	// tty_set_termios_ldisc(tty, disc);
+	// retval = tty_ldisc_open(tty, tty->ldisc);
+	// if (retval) {
+	// 	tty_ldisc_put(tty->ldisc);
+	// 	tty->ldisc = NULL;
+	// }
+// Perle end for trueport
 	return retval;
 }
 
diff --git a/drivers/tty/tty_port.c b/drivers/tty/tty_port.c
index 624d104bd145..c612bfae0b74 100644
--- a/drivers/tty/tty_port.c
+++ b/drivers/tty/tty_port.c
@@ -521,12 +521,18 @@ int tty_port_block_til_ready(struct tty_port *port,
 	}
 	if (filp == NULL || (filp->f_flags & O_NONBLOCK)) {
 		/* Indicate we are open */
-		if (C_BAUD(tty))
-			tty_port_raise_dtr_rts(port);
+// Perle start for trueport
+		if(!port->perle_iolan)
+		{
+// Perle end for trueport
+            if (C_BAUD(tty))
+                tty_port_raise_dtr_rts(port);
+// Perle start for trueport
+        }
+// Perle end for trueport
 		tty_port_set_active(port, true);
 		return 0;
 	}
-
 	if (C_CLOCAL(tty))
 		do_clocal = 1;
 
diff --git a/include/linux/perle_serial.h b/include/linux/perle_serial.h
new file mode 100644
index 000000000000..3e2a14b174bc
--- /dev/null
+++ b/include/linux/perle_serial.h
@@ -0,0 +1,31 @@
+#ifndef _LINUX_PERLE_SERIAL_H
+#define _LINUX_PERLE_SERIAL_H
+
+#if !defined(TRUE)
+#define TRUE    1
+#endif
+#if !defined(FALSE)
+#define FALSE   0
+#endif
+
+// forwarding options
+#define PERLE_SERIAL_FORWARD_ON_CHAR                    (DS_FORWARD_ON_CHAR1|DS_FORWARD_ON_CHAR2)
+#define PERLE_SERIAL_FORWARD_ON_FRAME                   (DS_FORWARD_START_CHAR1|DS_FORWARD_START_CHAR2|DS_FORWARD_END_CHAR1|DS_FORWARD_END_CHAR2)
+
+#define PERLE_SERIAL_FORWARD_STATE_START_1OF1           0
+#define PERLE_SERIAL_FORWARD_STATE_START_1OF2           1
+#define PERLE_SERIAL_FORWARD_STATE_START_2OF2           2
+#define PERLE_SERIAL_FORWARD_STATE_END_1OF1             3
+#define PERLE_SERIAL_FORWARD_STATE_END_1OF2             4
+#define PERLE_SERIAL_FORWARD_STATE_END_2OF2             5
+#define PERLE_SERIAL_FORWARD_STATE_WAITING_1OF1         6
+#define PERLE_SERIAL_FORWARD_STATE_WAITING_1OF2         7
+#define PERLE_SERIAL_FORWARD_STATE_WAITING_2OF2         8
+
+#define PERLE_SERIAL_DS_FLIPBUF_SIZE                    1024
+#define PERLE_SERIAL_FORWARD_SEND_TIMEOUT               (2 * HZ / 1000)
+
+//#define PERLE_SERIAL_DEBUG_RTSTOGGLE 1
+
+#endif  // _LINUX_PERLE_SERIAL_H
+
diff --git a/include/linux/serial_8250.h b/include/linux/serial_8250.h
index be65de65fe61..f9a2c3769f6c 100644
--- a/include/linux/serial_8250.h
+++ b/include/linux/serial_8250.h
@@ -11,7 +11,9 @@
 #include <linux/serial_core.h>
 #include <linux/serial_reg.h>
 #include <linux/platform_device.h>
-
+// Perle start for trueport
+#include <linux/perle_serial.h>
+// Perle end for trueport
 struct uart_8250_port;
 
 /*
@@ -133,6 +135,10 @@ struct uart_8250_port {
 	unsigned char		ier;
 	unsigned char		lcr;
 	unsigned char		mcr;
+// Perle start for trueport
+	unsigned char		mcr_mask;	/* mask of user bits */
+	unsigned char		mcr_force;	/* mask of forced bits */
+// Perle end for trueport
 	unsigned char		cur_iotype;	/* Running I/O type */
 	unsigned int		rpm_tx_active;
 	unsigned char		canary;		/* non-zero during system sleep
@@ -161,6 +167,126 @@ struct uart_8250_port {
 	void			(*dl_write)(struct uart_8250_port *up, u32 value);
 
 	struct uart_8250_em485 *em485;
+// Perle start for trueport
+	int uart_port_index;                                        // the index of port on the chips (master+slave)
+	int baud;
+	                                                            // on the iolan V, each serial port card has 2 exar chips in a master/slave configuration
+	                                                            // the master ports are 0-7 and the slave ports are 8-15
+#define SERIAL_8250_MEDIA_TYPE_TRISTATE	0
+#define SERIAL_8250_MEDIA_TYPE_232		1
+#define SERIAL_8250_MEDIA_TYPE_232_DCE	2
+#define SERIAL_8250_MEDIA_TYPE_422		3
+#define SERIAL_8250_MEDIA_TYPE_485_FULL	4
+#define SERIAL_8250_MEDIA_TYPE_485_HALF	5
+
+#define SERIAL_8250_MEDIA_TYPE_MASK		0xf
+
+#define SERIAL_8250_MEDIA_TERMINATION		0x10
+#define SERIAL_8250_MEDIA_FAST				0x20
+
+	void (*set_media_type)(struct uart_8250_port *,int);       // callback to 8250_pci.c to set the dce/dte mode on the uart port
+	unsigned int media_type;
+
+	unsigned int prescaler;     // 1 or 4
+	unsigned int mode8_16;      // 8=mode8x, 16=mode16x
+	
+	struct exar8250 *exar8250priv;	// back pointer
+	
+#if 0
+    /*
+     * GPIO signal support
+     */
+    int         DTR_gpio;
+    int         DTR_inverted;
+    int         DTR_present;
+    int         DTR_active;     // used to track the current state of the DTR signal/gpio
+                                // so we only write to the gpio if the state changes
+    int         DCD_gpio;
+    int         DCD_inverted;
+    int         DCD_present;
+    int         DSR_gpio;
+    int         DSR_inverted;
+    int         DSR_present;
+    int         RI_gpio;
+    int         RI_inverted;
+    int         RI_present;
+
+    u8          gpio_msr;       // emulate MSR (modem status register) for GPIOs
+                                // the delta and status bits for DCD, DSR and RI will be
+                                // updated
+#endif // if 0
+    // these are used for serialt (uart trace)
+    u8          last_mcr_written;
+    u8          last_msr_read;
+	u8			mcr_signal_flips;
+    // used for signal notification
+    unsigned short      rpt_mode;           // report mode   TRPT_(OFF,ON)
+    int                 rpt_pid;            // process ID
+    unsigned short      rpt_lsrmask;        // lsr mask      (TRPTSET >> 16)
+    unsigned short      rpt_user_sigmask;   // signals mask - linux API bits to look for (TRPTSET & 0xffff). TIOCM_DSR ...
+    unsigned short      rpt_sigmask;        // signals mask - uart bits to look for (TRPTSET & 0xffff). UART_MSR_DSR ...
+    unsigned short      rpt_LSR;            // lsr status    UART_LSR_(FE,OE,PE,BI)
+
+    // forwarding config
+    unsigned short      forwarding;        // options for packet forwarding
+    unsigned short        start_transmit_rule;
+    unsigned short        end_transmit_rule;
+    unsigned short      packet_size;       // maximum packet size
+    unsigned short      idle_time;         // idle time in msec
+    unsigned short      force_time;        // time to force transmit in msec
+    unsigned char       trigger_char1;     // transmit if char is encountered
+    unsigned char       trigger_char2;     // transmit if char is encountered
+    unsigned char       start_frame1;      // start of frame marker
+    unsigned char       start_frame2;      // start of frame marker
+    unsigned char       end_frame1;        // end of frame marker
+    unsigned char       end_frame2;        // end of frame marker
+    unsigned short      oneshot_config;    // oneshot forwarding config
+    unsigned char       direct_trigger;    // direct mode trigger character
+        // forwarding state info
+    unsigned short      oneshot_forwarding;// oneshot forwarding options that may be cleared
+    unsigned int        forward_state;     // state of forwarding
+    unsigned int           base_state;       // starting state
+    unsigned int           stored_char;      // was the char saved in the flip buf
+    unsigned char          saved_ch;         // save char for later
+    unsigned char          saved_st;         // save status for later
+    unsigned long          last_idle_time;         // last time idle timer was set in jiffies
+    // forwarding timers
+    struct timer_list       forward_idle_timer;     // forward on idle timer
+    struct timer_list       forward_force_timer;    // force forward timer
+    struct timer_list       forward_send_timer;     // send to tty process timer
+    struct timer_list       sigscan_delay_timer;    // signal scan delay timer
+
+    // forwarding flip buffer
+    char            *char_buf_ptr;
+    unsigned char   *flag_buf_ptr;
+    int             count;
+    char            *get_char_ptr;
+    unsigned char   *get_flag_ptr;
+    int             get_count;
+    int             buf_num;
+    unsigned char   char_buf[2*PERLE_SERIAL_DS_FLIPBUF_SIZE];
+    char            flag_buf[2*PERLE_SERIAL_DS_FLIPBUF_SIZE];
+
+    unsigned char   MCRmap;     // MCR value when mapping is used
+    unsigned char   out1;       // re-map for OUT1
+    unsigned char   out2;       // re-map for OUT2
+
+    int             traceMask;
+    int             traceSignals;
+    int             tracePortIndex; // 0 based port index of iolan
+    struct sigscan  sigScan;        // DSR/DCD signal scan
+
+    // rts toggle
+    struct timer_list rs232_rts_toggle_timer;
+    struct timer_list rs232_rts_toggle_initial_timer;
+    int rs232_rts_toggle_char_timeout;
+    int rs232_rts_toggle;
+    unsigned short rts_toggle_initial_delay;
+    unsigned short rts_toggle_final_delay;
+    struct timer_list signal_timer;
+    int signal_count;
+// Perle end for trueport
+
 	void			(*rs485_start_tx)(struct uart_8250_port *);
 	void			(*rs485_stop_tx)(struct uart_8250_port *);
 
@@ -209,6 +335,15 @@ int serial8250_console_exit(struct uart_port *port);
 
 void serial8250_set_isa_configurator(void (*v)(int port, struct uart_port *up,
 					       u32 *capabilities));
+// Perle start for trueport
+void serial8250_forward_idle_timer(struct timer_list *t);
+void serial8250_forward_force_timer(struct timer_list *t);
+void serial8250_forward_send_timer(struct timer_list *t);
+void serial8250_sigscan_delay_timer(struct timer_list *t);
+void serial8250_rs232_rts_toggle_timer(struct timer_list *t);
+void serial8250_rs232_rts_toggle_initial_timer(struct timer_list *t);
+void serial8250_signal_timer(struct timer_list *t);
+// Perle end for trueport
 
 #ifdef CONFIG_SERIAL_8250_RT288X
 int rt288x_setup(struct uart_port *p);
diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 052df85dfd59..6fcbe72a12a0 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -403,6 +403,11 @@ struct uart_ops {
 	void		(*poll_put_char)(struct uart_port *, unsigned char);
 	int		(*poll_get_char)(struct uart_port *);
 #endif
+// Perle start for trueport
+    int    (*get_rs485)(struct uart_port *,struct serial_rs485 *);
+    int    (*get_rs232_rts_toggle)(struct uart_port *);
+    int    (*uart_trace_add_ioctl)(struct uart_port *, int);
+// Perle end for trueport
 };
 
 #define NO_POLL_CHAR		0x00ff0000
@@ -470,6 +475,12 @@ struct uart_port {
 	unsigned char		iotype;			/* io access style */
 	unsigned char		quirks;			/* internal quirks */
 
+// Perle start for trueport
+	unsigned int	(*get_mstatus)(struct uart_port *);
+//	void (*get_logical_dcd)(struct uart_port *port);
+//	void (*get_logical_dsr)(struct uart_port *port);
+//	void (*get_logical_ri)(struct uart_port *port);
+// Perle end for trueport
 #define UPIO_UNKNOWN		((unsigned char)~0U)	/* UCHAR_MAX */
 #define UPIO_PORT		(SERIAL_IO_PORT)	/* 8b I/O port access */
 #define UPIO_HUB6		(SERIAL_IO_HUB6)	/* Hub6 ISA card */
@@ -587,6 +598,15 @@ struct uart_port {
 	struct gpio_desc	*rs485_rx_during_tx_gpio; /* Output GPIO that sets the state of RS485 RX during TX */
 	struct serial_iso7816   iso7816;
 	void			*private_data;		/* generic platform data pointer */
+// Perle start for trueport
+    char             drain_flag;
+    char        rs485_txing_no_echo;    // indicates when TXing for 485 hdx. this is used for echo suppression
+	unsigned char		card_id;		/* Perle card_id */
+	char		perle_unused;
+    // uart_xr17v358_t uart_xr17v358_regs;
+    unsigned int    major;      // save the major_id of the device. required for reporting sigscan info to userspace
+                                // since uart port numbering in the kernel does not correspond to the physical ports on the iolan
+// Perle end for trueport
 };
 
 /**
diff --git a/include/linux/tty_port.h b/include/linux/tty_port.h
index 6b367eb17979..ecb2c89361c9 100644
--- a/include/linux/tty_port.h
+++ b/include/linux/tty_port.h
@@ -111,7 +111,11 @@ struct tty_port {
 	wait_queue_head_t	delta_msr_wait;
 	unsigned long		flags;
 	unsigned long		iflags;
-	unsigned char		console:1;
+	unsigned char		console:1,
+// Perle start for trueport
+	low_latency:1,	/* optional: tune for latency */
+	perle_iolan:1;	/* option set from UPF_PERLE_IOLAN */
+// Perle end for trueport
 	struct mutex		mutex;
 	struct mutex		buf_mutex;
 	unsigned char		*xmit_buf;
diff --git a/include/uapi/asm-generic/ioctls.h b/include/uapi/asm-generic/ioctls.h
index cdc9f4ca8c27..fed779daa224 100644
--- a/include/uapi/asm-generic/ioctls.h
+++ b/include/uapi/asm-generic/ioctls.h
@@ -117,5 +117,93 @@
 #define TIOCPKT_IOCTL		64
 
 #define TIOCSER_TEMT	0x01	/* Transmitter physically empty */
+// Perle start for trueport
 
+#define TRPTSET		_IOW('t', 130, int)
+#define TRPTGET		_IOR('t', 131, struct ttyrpt)
+#define TRPTGETRST	_IOR('t', 132, struct ttyrpt)
+#define TRPTSETPID	_IOW('t', 133, int)
+#define TIOCSERDS	_IOW('t', 134, int)
+#define TIOCFWDDS	_IOW('t', 135, struct fwdpkt)
+#define TIOCMAPDTR	_IOW('t', 136, int)
+#define TIOCMAPRTS	_IOW('t', 137, int)
+#define TRACECONTROL _IOW('t', 138, int)
+#define TRACEREAD    _IOR('t', 139, int)
+#define TIOCOSARMDS	_IOW('t', 140, int)
+#define TRESETCOUNT	_IOW('t', 141, int)
+#define TSIGSCAN	_IOW('t', 142, struct sigscan)
+#define TIOCCICOUNT _IOW('t', 143, int)             /* clear port stats like rx, tx counts */
+#define TRTSCONTROL	_IOW('t', 144, struct rts_control)
+#define TIOCSLEEP	_IOW('t', 145, int)
+
+// bit defs for arg to TIOCCICOUNT ioctl 
+#define TIOCCICOUNT_CTS         0x0001
+#define TIOCCICOUNT_DSR         0x0002
+#define TIOCCICOUNT_RNG         0x0004
+#define TIOCCICOUNT_DCD         0x0008
+#define TIOCCICOUNT_TX          0x0010
+#define TIOCCICOUNT_RX          0x0020
+#define TIOCCICOUNT_FRAME       0x0040
+#define TIOCCICOUNT_PARITY      0x0080
+#define TIOCCICOUNT_OVERRUN     0x0100
+#define TIOCCICOUNT_BRK         0x0200
+#define TIOCCICOUNT_BUFOVERRUN  0x0400
+#define TIOCCICOUNT_ALL         0xffff
+
+/*
+ * These are the definitions for the Line Status Register
+ */
+#define TIOCSER_TEMPT           0x40  /* Transmitter empty */
+#define TIOCSER_THRE            0x20  /* Transmit-hold-register empty */
+#define TIOCSER_BI              0x10  /* Break interrupt indicator */
+#define TIOCSER_FE              0x08  /* Frame error indicator */
+#define TIOCSER_PE              0x04  /* Parity error indicator */
+#define TIOCSER_OE              0x02  /* Overrun error indicator */
+#define TIOCSER_DR              0x01  /* Receiver data ready */
+
+/* modem lines */
+#define TIOCM_LE	0x001
+#define TIOCM_DTR	0x002
+#define TIOCM_RTS	0x004
+#define TIOCM_ST	0x008
+#define TIOCM_SR	0x010
+#define TIOCM_CTS	0x020
+#define TIOCM_CAR	0x040
+#define TIOCM_RNG	0x080
+#define TIOCM_DSR	0x100
+#define TIOCM_CD	TIOCM_CAR
+#define TIOCM_RI	TIOCM_RNG
+#define TIOCM_OUT1	0x2000
+#define TIOCM_OUT2	0x4000
+#define TIOCM_LOOP	0x8000
+
+/* c_lflag bits */
+#define ISIG	0000001
+#define ICANON	0000002
+#define XCASE	0000004
+#define ECHO	0000010
+#define ECHOE	0000020
+#define ECHOK	0000040
+#define ECHONL	0000100
+#define NOFLSH	0000200
+#define TOSTOP	0000400
+#define ECHOCTL	0001000
+#define ECHOPRT	0002000
+#define ECHOKE	0004000
+#define FLUSHO	0010000
+#define PENDIN	0040000
+#define IEXTEN	0100000
+#define EXTPROC	0200000
+#define NO_XLATE 01000000
+
+
+#define FANOUT_IOC_MAGIC        'k'
+#define FANOUT_IOCT_FLUSH       _IO(FANOUT_IOC_MAGIC, 0x80)
+#define FANOUT_IOCT_READMARK    _IO(FANOUT_IOC_MAGIC, 0x81)
+
+/* the following bits represent the requested report mode */
+/* this is the data that follows a TRPTSET ioclt */
+#define TRPT_OFF	0x0000			// report mode off
+#define TRPT_ON		0x0001			// report mode on
+// Perle end for trueport
 #endif /* __ASM_GENERIC_IOCTLS_H */
diff --git a/include/uapi/asm-generic/termbits.h b/include/uapi/asm-generic/termbits.h
index 890ef29053e2..00902ccd156a 100644
--- a/include/uapi/asm-generic/termbits.h
+++ b/include/uapi/asm-generic/termbits.h
@@ -146,4 +146,107 @@ struct ktermios {
 #define	TCSADRAIN	1
 #define	TCSAFLUSH	2
 
+// Perle start for trueport
+#define CBAUDEX2 0020000
+#define B1843200 0020001
+#define B3686400 0020002
+#define B28800   0020003
+// Perle-end
+
+// Perle-start
+#define PSPACE  00100000
+#define CTSFLOW 00200000
+#define RTSFLOW 00400000
+#define PARMARK	01000000
+#define CSTOP15 02000000
+// Perle-end
+// PERLE specific - start
+/* the following bits represent the requested report mode */
+/* this is the data that follows a TRPTSET ioclt */
+#define TRPT_SPCD	0x80000000			// SPCD task (lsrmask)
+#define TRPT_PRIVATE 	0xf0000000			// reserved (lsrmask)
+
+struct ttyrpt
+{
+	unsigned short lsrmask;		// lsr mask      (TRPTSET >> 16)
+	unsigned short sigmask;		// signals mask	 (TRPTSET & 0xffff)
+
+	unsigned short signals;		// signal levels TIOCM_(DTR,RTS,CTS,DSR,RI,CD)
+	unsigned short lsr;		// lsr status    TIOCSER_(FE,OE,PE,BI)
+};
+
+/* the following bits represent the requested report mode */
+/* this is the data that follows a TRPTSET ioclt */
+#define TRPT_OFF	0x0000			// report mode off
+#define TRPT_ON		0x0001			// report mode on
+
+#define DS_RS232_FD                 0x0001
+#define DS_RS422_FD                 0x0002
+#define DS_RS485_FD                 0x0004
+#define DS_RS485_HD                 0x0008
+#define DS_LINE_TERM                0x0010
+#define DS_DRIVERCTL_AUTO           0x0020
+#define DS_ECHO_SUPRESSION          0x0040
+#define DS_SINGLE_CHAR_INTERRUPT    0x0080
+#define DS_SLEW_RATE_LIMIT          0x0100
+#define DS_SIGNALCTL_MANUAL         0x0200
+#define DS_SIGNALCTL_INACTIVE       0x0400
+#define DS_FIFO_DIRECT              0x0800
+#define DS_IGNORE_LINE_ERRORS       0x1000
+
+
+struct fwdpkt
+{
+        unsigned short		forwarding;        // options for packet forwarding
+        unsigned short        start_transmit_rule;
+        unsigned short        end_transmit_rule;
+        unsigned short		packet_size;       // maximum packet size
+        unsigned short		idle_time;         // idle time in msec
+        unsigned short		force_time;        // time to force transmit in msec
+        unsigned char		trigger_char1;     // transmit if char is encountered
+        unsigned char		trigger_char2;     // transmit if char is encountered
+        unsigned char		start_frame1;      // start of frame marker
+        unsigned char		start_frame2;      // start of frame marker
+        unsigned char		end_frame1;        // end of frame marker
+        unsigned char		end_frame2;        // end of frame marker
+		unsigned short		oneshot_config;	   // oneshot forwarding config
+		unsigned char		direct_trigger;    // one-time filter for direct service types
+};
+
+// forwarding field
+#define DS_FORWARD_ON_COUNT        		0x0001
+#define DS_FORWARD_ON_IDLE         		0x0002
+#define DS_FORWARD_ON_TIME         		0x0004
+#define DS_FORWARD_ON_CHAR1        		0x0010
+#define DS_FORWARD_ON_CHAR2        		0x0020
+#define DS_FORWARD_START_CHAR1     		0x0100
+#define DS_FORWARD_START_CHAR2     		0x0200
+#define DS_FORWARD_END_CHAR1   			0x1000
+#define DS_FORWARD_END_CHAR2   			0x2000
+
+#define DS_ONESHOT_ON_DIRECT_TRIGGER	0x0001
+
+// transmit rules
+#define DS_FORWARD_TRANS_STRIP     0
+#define DS_FORWARD_TRANS_TRIG      1
+#define DS_FORWARD_TRANS_TRIG_1    2
+#define DS_FORWARD_TRANS_TRIG_2    3
+
+#define DS_FORWARD_PACKET_SIZE_MAX 1024
+
+struct sigscan {
+	int		pid;					// pid of caller to signal
+	unsigned short sigmask;		// handshake signals to scan
+	unsigned short sigdrop;		// handshake signals to drop
+	unsigned short msec;			// milliseconds to delay
+	unsigned short line;			// line (port) number
+};
+
+#define RTS_TOGGLE_ON	0x0001
+struct rts_control {
+    unsigned short flags;
+    unsigned short initial_delay;
+    unsigned short final_delay;
+};
+// Perle end for trueport
 #endif /* __ASM_GENERIC_TERMBITS_H */
diff --git a/include/uapi/linux/serial.h b/include/uapi/linux/serial.h
index 53bc1af67a41..297d228f38d2 100644
--- a/include/uapi/linux/serial.h
+++ b/include/uapi/linux/serial.h
@@ -149,6 +149,33 @@ struct serial_rs485 {
 #define SER_RS485_ADDR_RECV		(1 << 7)
 #define SER_RS485_ADDR_DEST		(1 << 8)
 
+// Perle start for trueport
+#define SER_RS485_USE_GPIO              (1 << 5)
+#define SER_RS485_HDX               (1 << 16)       // 0x00010000, half duplex if enabled
+#define SER_RS485_ECHO_SUPPRESSION  (1 << 17)       // 0x00020000, echo suppression for half duplex only
+#define SER_RS4XX_LINE_TERMINATION  (1 << 18)       // 0x00040000, line termination
+#define SER_RS485_DRIVERCTL_AUTO    (1 << 19)       // 0x00080000, driver controls RTS (TX envelope for 485 hdx and fdx only. for 422 RTS is always active)
+#define SER_RS422_ENABLED           (1 << 20)       // 0x00100000, 422 enabled
+#define SER_RS4XX_INVERT_RTS        (1 << 21)       // 0x00200000, invert RTS when accessing the MCR because the transceiver uses an inverted RTS signal to control the TX
+                                                    //           normally MCR[RTS]=1, causes 0V from the UART and results in RTS high
+                                                    //                    MCR[RTS]=0, causes 3.3V from the UART and results in RTS low
+                                                    //           with RS4XX
+                                                    //                    MCR[RTS]=1, causes 0V from the UART and results in RTS low (TX off)
+                                                    //                    MCR[RTS]=0, causes 3.3V from the UART and results in RTS high (TX on)
+#define SER_RSXXX_IGNORE_LINE_ERRORS    (1 << 22)   // 0x00400000, ignore line errors (parity and framing)
+#define SER_RSXXX_SINGLE_CHAR_INTERRUPT (1 << 23)   // 0x00800000, single char interrupt
+#define SER_RSXXX_SIGNALCTL_MANUAL      (1 << 24)   // 0x01000000, manual signal control
+#define SER_RSXXX_SIGNALCTL_INACTIVE    (1 << 25)   // 0x02000000, DTR and RTS inactive
+#define SER_RSXXX_FIFO_DIRECT           (1 << 26)   // 0x04000000, fifo direct mode
+#define SER_RS232_ENABLED               (1 << 27)   // 0x08000000, 232 enabled
+
+#define SER_RSXXX_DTE_DCE_MODE_MASK     (3 << 28)
+#define SER_RSXXX_DTE_DCE_MODE_DISABLED (0 << 28)
+#define SER_RSXXX_DTE_DCE_MODE_DTE      (1 << 28)
+#define SER_RSXXX_DTE_DCE_MODE_DCE      (2 << 28)			
+
+#define SER_RS232_DCE				    (1 << 28)	// 0x10000000, choose DCE (needs SER_RS232_ENABLED also)
+// Perle end for trueport
 	__u32	delay_rts_before_send;
 	__u32	delay_rts_after_send;
 
diff --git a/include/uapi/linux/tty_flags.h b/include/uapi/linux/tty_flags.h
index cf25056d4b27..123b0690eb77 100644
--- a/include/uapi/linux/tty_flags.h
+++ b/include/uapi/linux/tty_flags.h
@@ -71,6 +71,9 @@
 #define ASYNC_BUGGY_UART	(1U << ASYNCB_BUGGY_UART)
 #define ASYNC_AUTOPROBE		(1U << ASYNCB_AUTOPROBE)
 #define ASYNC_MAGIC_MULTIPLIER	(1U << ASYNCB_MAGIC_MULTIPLIER)
+// Perle start for trueport
+#define ASYNC_PERLE_IOLAN	(1U << ASYNCB_PERLE_IOLAN)
+// Perle end for trueport
 
 #define ASYNC_FLAGS		((1U << (ASYNCB_LAST_USER + 1)) - 1)
 #define ASYNC_DEPRECATED	(ASYNC_SPLIT_TERMIOS | ASYNC_SESSION_LOCKOUT | \
diff --git a/include/uapi/linux/uart_trace.h b/include/uapi/linux/uart_trace.h
new file mode 100644
index 000000000000..f886db2ba24e
--- /dev/null
+++ b/include/uapi/linux/uart_trace.h
@@ -0,0 +1,91 @@
+#ifndef _UAPI_LINUX_UART_TRACE_H
+#define _UAPI_LINUX_UART_TRACE_H
+
+#define MAX_TRACE_DATA 251
+#define UTIME_MANTISSA_BITS 10
+typedef struct
+{
+	unsigned char len;		/* 1->255 bytes follow */
+	unsigned char type;
+    unsigned short utime;
+	unsigned char port;
+	char data[MAX_TRACE_DATA];
+} TraceEntry;
+
+typedef struct
+{
+    unsigned long mask;
+    int maxTraceLength;
+    int port;           // 0 based port index of iolan
+} TraceControl;
+
+typedef struct
+{
+	int 	dataLen;						/* transferred length */
+	int		remLen;							/* amount left to transfer */
+} TraceRead;
+
+
+enum
+{
+	TRACE_HEADER,
+	TRACE_IN,
+	TRACE_OUT,
+	TRACE_SIGNALS,
+	TRACE_SPECIAL,
+	TRACE_IOCTL
+};
+
+#define TRACE_BITS_IN (1 << TRACE_IN)
+#define TRACE_BITS_OUT (1 << TRACE_OUT)
+#define TRACE_BITS_SIGNALS (1 << TRACE_SIGNALS)
+#define TRACE_BITS_SPECIAL (1 << TRACE_SPECIAL)
+#define TRACE_BITS_IOCTL (1 << TRACE_IOCTL)
+
+enum
+{
+	UTR_MASK = 0xff00,
+	UTR_PARITY = 0x100,
+	UTR_FRAME = 0x200,
+	UTR_OVERRUN = 0x300,
+	UTR_TTY_OVERRUN = 0x400,
+	UTR_RX_BREAK = 0x500,
+	UTR_TX_BREAK = 0x600
+};
+
+typedef struct
+{
+	char *pBuf;							/* pointer to FIFO buffer */
+	int	len;							/* length of buffer */
+	int	start;							/* oldest index */
+	int	end;							/* next index */
+	int	options;						/* trace options */
+	
+} TraceFifo;
+
+#define UART_TRACE_LENGTH 32768
+typedef struct
+{
+	TraceFifo fifo;
+	char	data[UART_TRACE_LENGTH];
+	
+	unsigned long jiffies;
+	ktime_t microticks;
+	
+	int readLength;
+	
+} UartTrace;
+
+
+
+
+int uartTraceStart(int readLength);
+int uartTraceRead(TraceRead *pTR);
+int uartTraceAdd(int port, int type, int len, const unsigned char *pData);
+int uartTraceAddSignals(int port, int *pSignals, int MCR, int MSR);         // MCR and MSR use the UART_MCR_xxxx and UART_MSR_xxxx uart register #defines
+int uartTraceAddSignalsTIOCM(int port, int *pSignals, int MCR, int MSR);    // MCR and MSR use the ioctl TIOCM_xxx #defines
+int uartTraceAddSpecial(int port, short sp);
+int uartTraceAddIoctl(int port, int ioctl);
+
+#endif	/* __UART_TRACE__ */
+
